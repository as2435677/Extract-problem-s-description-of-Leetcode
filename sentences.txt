 Given an array nums sorted in ascending order , return true if and only if you can split it into 1 or more subsequences such that each subsequence consists of consecutive integers and has length at least 3 .
 Write a function that reverses a string . The input string is given as an array of characters char [ ] .
 Do not allocate extra space for another array , you must do this by modifying the input array in-place with O ( 1 ) extra memory .
 Since the answer may be too large , return it modulo 10 ^ 9 + 7 .
 The kingdom has a well-defined order of inheritance that consists of the king as the first member . Let's define the recursive function Successor ( x , curOrder ) , which given a person x and the inheritance order so far , returns who should be the next person after x in the order of inheritance .
 if x is the king return null
 else return Successor ( x's parent , curOrder )
 else return x's oldest child who's not in curOrder
 Calling Successor ( king , curOrder ) will return Alice , so we append to curOrder to get [ " king " , " Alice " ] .
 Calling Successor ( Alice , curOrder ) will return Jack , so we append to curOrder to get [ " king " , " Alice " , " Jack " ] .
 Calling Successor ( Jack , curOrder ) will return Bob , so we append to curOrder to get [ " king " , " Alice " , " Jack " , " Bob " ] .
 Calling Successor ( Bob , curOrder ) will return null . Thus the order of inheritance will be [ " king " , " Alice " , " Jack " , " Bob " ] .
 Using the above function , we can always obtain a unique order of inheritance .
 ThroneInheritance ( string kingName ) Initializes an object of the ThroneInheritance class . The name of the king is given as part of the constructor .
 t.getInheritanceOrder ( ) ; / / return [ " king " , " andy " , " matthew " , " bob " , " alex " , " asha " , " catherine " ]
 t.getInheritanceOrder ( ) ; / / return [ " king " , " andy " , " matthew " , " alex " , " asha " , " catherine " ]
 Given a string IP , return " IPv4 " if IP is a valid IPv4 address , " IPv6 " if IP is a valid IPv6 address or " Neither " if IP is not a correct IP of any type .
 Explanation : This is a valid IPv4 address , return " IPv4 " .
 Explanation : This is a valid IPv6 address , return " IPv6 " .
 You are given an m x n matrix M initialized with all 0's and an array of operations ops , where ops [ i ] = [ a i , b i ] means M [ x ] [ y ] should be incremented by one for all 0 &lt; = x &lt; a i and 0 &lt; = y &lt; b i .
 Count and return the number of maximum integers in the matrix after performing all the operations .
 Explanation : The maximum integer in M is 2 , and there are four of it in M . So return 4 .
 A zero-indexed array A of length N contains all integers from 0 to N-1 . Find and return the longest length of set S , where S [ i ] = { A [ i ] , A [ A [ i ] ] , A [ A [ A [ i ] ] ] , ... } subjected to the rule below .
 pick return a point as an array of integer coordinates [ p_x , p_y ]
 The input is two lists : the subroutines called and their arguments . Solution's constructor has one argument , the array of rectangles rects . pick has no arguments . Arguments are always wrapped with a list , even if there aren't any .
 If there are multiple valid answers return any of them . If it is impossible to avoid flood return an empty array .
 Now your job is to find the total Hamming distance between all pairs of the given numbers .
 Elements of the given array are in the range of 0 to 10 ^ 9
 Return True if the equation is solvable otherwise return False .
 The input string length won't exceed 1000 .
 Alice and Bob take turns playing a game , with Alice starting first .
 Given a positive integer n . Return True if and only if Alice wins the game otherwise return False , assuming both players play optimally .
 Given a binary tree , return all root-to-leaf paths .
 Given three integers a , b and c , return any string s , which satisfies following conditions :
 If there is no such string s return the empty string " " .
 Return the largest possible height of your billboard installation . If you can not support the billboard , return 0 .
 Explanation : The billboard can not be supported , so we return 0 .
 Return true if and only if the given array A is monotonic .
 Reverse bits of a given 32 bits unsigned integer .
 Note that in some languages such as Java , there is no unsigned integer type . In this case , both input and output will be given as a signed integer type . They should not affect your implementation , as the integer's internal binary representation is the same , whether it is signed or unsigned .
 In Java , the compiler represents the signed integers using 2's complement notation . Therefore , in Example 2 above , the input represents the signed integer-3 and the output represents the signed integer-1073741825 .
 Explanation : The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596 , so return 964176192 which its binary representation is 00111001011110000010100101000000 .
 Explanation : The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293 , so return 3221225471 which its binary representation is 10111111111111111111111111111111 .
 The input must be a binary string of length 32
 You are given an array points representing integer coordinates of some points on a 2D-plane , where points [ i ] = [ x i , y i ] .
 Given a binary tree , return the zigzag level order traversal of its nodes' values . ( ie , from left to right , then right to left for the next level and alternate between ) .
 return its zigzag level order traversal as :
 Return the minimum number of K-bit flips required so that there is no 0 in the array . If it is not possible , return-1 .
 You are given a string s , and an array of pairs of indices in the string pairs where pairs [ i ] = [ a , b ] indicates 2 indices ( 0-indexed ) of the string .
 You can swap the characters at any pair of indices in the given pairs any number of times .
 We will remove one node from the initial list , completely removing it and any connections from this node to any other node . Return the node that if removed , would minimize M ( initial ) . If multiple nodes could be removed to minimize M ( initial ) , return such a node with the smallest index .
 In a given grid , each cell can have one of three values :
 Return the minimum number of minutes that must elapse until no cell has a fresh orange . If this is impossible , return-1 instead .
 Given two strings s1 and s2 of the same length , return true if s2 is a scrambled string of s1 , otherwise , return false .
 As there is one possible scenario that led s1 to be scrambled to s2 , we return true .
 We are given an array A of positive integers , and two positive integers L and R ( L &lt; = R ) .
 Given an array of integers nums sorted in ascending order , find the starting and ending position of a given target value .
 If target is not found in the array , return [-1 , -1 ] .
 We start at bus stop S ( initially not on a bus ) , and we want to go to bus stop T . Travelling by buses only , what is the least number of buses we must take to reach our destination ? Return -1 if it is not possible .
 The best strategy is take the first bus to the bus stop 7 , then take the second bus to the bus stop 6 .
 int get ( int index ) Get the value of the index th node in the linked list . If the index is invalid , return-1 .
 myLinkedList.get ( 1 ) ; / / return 2
 myLinkedList.get ( 1 ) ; / / return 3
 Hint : Length of the given string will not exceed 100 .
 If your line go through the edge of a brick , then the brick is not considered as crossed . You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks .
 Given a collection of distinct integers , return all possible permutations .
 You are given a tree with n nodes numbered from 0 to n-1 in the form of a parent array where parent [ i ] is the parent of node i . The root of the tree is node 0 .
 Implement the function getKthAncestor ( int node , int k ) to return the k-th ancestor of the given node . If there is no such ancestor , return-1 .
 Given a range [ m , n ] where 0 &lt; = m &lt; = n &lt; = 2147483647 , return the bitwise AND of all numbers in this range , inclusive .
 You are given an array of integers nums , there is a sliding window of size k which is moving from the very left of the array to the very right . You can only see the k numbers in the window . Each time the sliding window moves right by one position .
 You are given the root of a binary tree where each node has a value 0 or 1 . Each root-to-leaf path represents a binary number starting with the most significant bit . For example , if the path is 0-&gt; 1-&gt; 1-&gt; 0-&gt; 1 , then this could represent 01101 in binary , which is 13 .
 What is the minimum candies you must give ?
 You are given a license key represented as a string S which consists only alphanumeric character and dashes . The string is separated into N +1 groups by N dashes .
 Given an integer n , return all distinct solutions to the n-queens puzzle .
 Given an integer array nums and an integer k , return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence , nums [ i ] and nums [ j ] , where i &lt; j , the condition j-i &lt; = k is satisfied .
 Given the root of a binary tree , return the preorder traversal of its nodes' values .
 Return the result of evaluating a given boolean expression , represented as a string .
 expression is a valid expression representing a boolean , as given in the description .
 On an 8 x 8 chessboard , there is one white rook . There also may be empty squares , white bishops , and black pawns . These are given as characters' R' ,' .' ,' B' , and' p' respectively . Uppercase characters represent white pieces , and lowercase characters represent black pieces .
 but the second term did not exist . Since the last term exhausted does not exist , we return -1 .
 Find the minimal balls you have to insert to remove all the balls on the table . If you can not remove all the balls , output -1 .
 Both input strings will be non-empty and only contain characters' R' ,' Y' ,' B' ,' G' ,' W' .
 Given a linked list , swap every two adjacent nodes and return its head .
 Given an array A of integers , return true if and only if we can partition the array into three non-empty parts with equal sums .
 The given binary tree will have between 1 and 3000 nodes .
 Given a list of strings words representing an English Dictionary , find the longest word in words that can be built one character at a time by other words in words . If there is more than one possible answer , return the longest word with the smallest lexicographical order . If there is no answer , return the empty string .
 All the strings in the input will only contain lowercase letters .
 Given a string input representing the file system in the explained format , return the length of the longest absolute path to a file in the abstracted file system . If there is no file in the system , return 0 .
 Input : input = " dir \ n \ tsubdir1 \ n \ tsubdir2 \ n \ t \ tfile.ext "
 Input : input = " dir \ n \ tsubdir1 \ n \ t \ tfile1.ext \ n \ t \ tsubsubdir1 \ n \ tsubdir2 \ n \ t \ tsubsubdir2 \ n \ t \ t \ tfile2.ext "
 We return 32 since it is the longest absolute path to a file .
 Input : input = " a "
 Input : input = " file1.txt \ nfile2.txt \ nlongfile.txt "
 input may contain lowercase or uppercase English letters , a new line character' \ n' , a tab character' \ t' , a dot' .' , a space '' , and digits .
 Given an arbitrary ransom note string and another string containing letters from all the magazines , write a function that will return true if the ransom note can be constructed from the magazines ; otherwise , it will return false .
 What is the least number of refueling stops the car must make in order to reach its destination ? If it can not reach the destination , return-1 .
 We made 2 refueling stops along the way , so we return 2 .
 wordDictionary.search ( " pad " ) ; / / return False
 wordDictionary.search ( " bad " ) ; / / return True
 wordDictionary.search ( " . ad " ) ; / / return True
 wordDictionary.search ( " b. . " ) ; / / return True
 Length of the given string and k will in the range [ 1 , 10000 ]
 Given the roots of two binary trees root1 and root2 , return true if the two trees are flip equivelent or false otherwise .
 It's guarateed that there is at least one valid solution . If there are many valid solutions you can return any of them .
 Return the minimum integer you can obtain also as a string .
 Explanation : The steps to obtain the minimum integer from 4321 with 4 adjacent swaps are shown .
 Explanation : It's ok for the output to have leading zeros , but the input is guaranteed not to have any leading zeros .
 You're given strings J representing the types of stones that are jewels , and S representing the stones you have . Each character in S is a type of stone you have . You want to know how many of the stones you have are also jewels .
 Return True if every binary code of length k is a substring of s . Otherwise , return False .
 Given a blacklist B containing unique integers from [ 0 , N ) , write a function to return a uniform random integer from [ 0 , N ) which is NOT in B .
 The input is two lists : the subroutines called and their arguments . Solution's constructor has two arguments , N and the blacklist B . pick has no arguments . Arguments are always wrapped with a list , even if there aren't any .
 If there are multiple valid itineraries , you should return the itinerary that has the smallest lexical order when read as a single string . For example , the itinerary [ " JFK " , " LGA " ] has a smaller lexical order than [ " JFK " , " LGB " ] .
 As the answer can be very large , return the answer modulo 10 ^ 9 + 7 .
 You are given an array of distinct positive integers locations where locations [ i ] represents the position of city i . You are also given integers start , finish and fuel representing the starting city , ending city , and the initial amount of fuel you have , respectively .
 Since the answer may be too large , return it modulo 10 ^ 9 + 7 .
 randomizedSet.getRandom ( ) ; / / getRandom ( ) should return either 1 or 2 randomly .
 randomizedSet.insert ( 2 ) ; / / 2 was already in the set , so return false .
 randomizedSet.getRandom ( ) ; / / Since 2 is the only number in the set , getRandom ( ) will always return 2 .
 Given n and m which are the dimensions of a matrix initialized by zeros and given an array indices where indices [ i ] = [ ri , ci ] . For each pair of [ ri , ci ] you have to increment all cells in row ri and column ci by 1 .
 You are given an m * n matrix , mat , and an integer k , which has its rows sorted in non-decreasing order .
 Given two integers steps and arrLen , return the number of ways such that your pointer still at index 0 after exactly steps steps .
 Since the answer may be too large , return it modulo 10 ^ 9 + 7 .
 Given an array nums of 0s and 1s and an integer k , return True if all 1's are at least k places away from each other , otherwise return False .
 Whenever we would move outside the boundary of the grid , we continue our walk outside the grid ( but may return to the grid boundary later . )
 Now we have another string p . Your job is to find out how many unique non-empty substrings of p are present in s . In particular , your input is the string p and you need to output the number of different non-empty substrings of p in the string s .
 Return true if there is a cycle in the linked list . Otherwise , return false .
 Given an integer array of digits , return the largest multiple of three that can be formed by concatenating some of the given digits in any order .
 Since the answer may not fit in an integer data type , return the answer as a string .
 If there is no answer return an empty string .
 You are given an integer array A . From some starting index , you can make a series of jumps . The ( 1st , 3rd , 5th , ... ) jumps in the series are called odd-numbered jumps , and the ( 2nd , 4th , 6th , ... ) jumps in the series are called even-numbered jumps . Note that the jumps are numbered , not the indices .
 Return the shortest completing word in words . It is guaranteed an answer exists . If there are multiple shortest completing words , return the first one that occurs in words .
 If the sequence is possible to stamp , then return an array of the index of the left-most letter being stamped at each turn . If the sequence is not possible to stamp , return an empty array .
 For example , if the sequence is " ababc " , and the stamp is " abc " , then we could return the answer [ 0 , 2 ] , corresponding to the moves " ????? "-&gt; " abc ?? "-&gt; " ababc " .
 Given two integer arrays startTime and endTime and given an integer queryTime .
 Return the number of students doing their homework at time queryTime . More formally , return the number of students where queryTime lays in the interval [ startTime [ i ] , endTime [ i ] ] inclusive .
 On an infinite number line , the position of the i-th stone is given by stones [ i ] . Call a stone an endpoint stone if it has the smallest or largest position .
 Should output :
 There are n cities numbered from 0 to n-1 . Given the array edges where edges [ i ] = [ from i , to i , weight i ] represents a bidirectional and weighted edge between cities from i and to i , and given the integer distanceThreshold .
 Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold , If there are multiple such cities , return the city with the greatest number .
 Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4 , but we have to return city 3 since it has the greatest number .
 Given an array of strings products and a string searchWord . We want to design a system that suggests at most three product names from products after each character of searchWord is typed . Suggested products should have common prefix with the searchWord . If there are more than three products with a common prefix return the three lexicographically minimums products .
 There're totally 4 courses , but you can take 3 courses at most :
 First , take the 1st course , it costs 100 days so you will finish it on the 100th day , and ready to take the next course on the 101st day .
 Second , take the 3rd course , it costs 1000 days so you will finish it on the 1100th day , and ready to take the next course on the 1101st day .
 Third , take the 2nd course , it costs 200 days so you will finish it on the 1300th day .
 You can't take two courses simultaneously .
 You are given a string s that consists of lower case English letters and brackets .
 Explanation : The figure above represents the given binary tree . There are three paths going from the root node to leaf nodes : the red path [ 2,3,3 ] , the green path [ 2,1,1 ] , and the path [ 2,3,1 ] . Among these paths only red path and green path are pseudo-palindromic paths since the red path [ 2,3,3 ] can be rearranged in [ 3,2,3 ] ( palindrome ) and the green path [ 2,1,1 ] can be rearranged in [ 1,2,1 ] ( palindrome ) .
 Explanation : The figure above represents the given binary tree . There are three paths going from the root node to leaf nodes : the green path [ 2,1,1 ] , the path [ 2,1,3,1 ] , and the path [ 2,1 ] . Among these paths only the green path is pseudo-palindromic since [ 2,1,1 ] can be rearranged in [ 1,2,1 ] ( palindrome ) .
 The given binary tree will have between 1 and 10 ^ 5 nodes .
 Given the positions of houses and heaters on a horizontal line , return the minimum radius standard of heaters so that those heaters could cover all houses .
 magicDictionary.search ( " hello " ) ; / / return False
 magicDictionary.search ( " hhllo " ) ; / / We can change the second' h' to' e' to match " hello " so we return True
 magicDictionary.search ( " hell " ) ; / / return False
 magicDictionary.search ( " leetcoded " ) ; / / return False
 Given an array of strings strs , group the anagrams together . You can return the answer in any order .
 Given the encoded message containing digits and the character' *' , return the total number of ways to decode it .
 Also , since the answer may be very large , you should return the output mod 10 9 + 7 .
 The length of the input string will fit in range [ 1 , 10 5 ] .
 The input string will only contain the character' *' and digits' 0'-' 9' .
 Assume you are an awesome parent and want to give your children some cookies . But , you should give each child at most one cookie .
 Each child i has a greed factor g [ i ] , which is the minimum size of a cookie that the child will be content with ; and each cookie j has a size s [ j ] . If s [ j ] &gt; = g [ i ] , we can assign the cookie j to the child i , and the child i will be content . Your goal is to maximize the number of your content children and output the maximum number .
 You need to output 1 .
 You need to output 2 .
 Given a starting point ( sx , sy ) and a target point ( tx , ty ) , return True if and only if a sequence of moves exists to transform the point ( sx , sy ) to ( tx , ty ) . Otherwise , return False .
 You are given an API bool isBadVersion ( version ) which returns whether version is bad . Implement a function to find the first bad version . You should minimize the number of calls to the API .
 You are given an integer array nums . The value of this array is defined as the sum of | nums [ i ]-nums [ i +1 ] | for all 0 &lt; = i &lt; nums.length-1 .
 You are allowed to select any subarray of the given array and reverse it . You can perform this operation only once .
 After doing so , return the head of the final linked list . You may return any such answer .
 The given linked list will contain between 1 and 1000 nodes .
 Return True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree otherwise return False .
 The given linked list will contain between 1 and 100 nodes .
 The given binary tree will contain between 1 and 2500 nodes .
 Given a non-negative integer n which represents the number of LEDs that are currently on , return all possible times the watch could represent .
 The order of output does not matter .
 Among all possible binary trees considered , return the smallest possible sum of the values of each non-leaf node . It is guaranteed this sum fits into a 32-bit integer .
 You are given a grid of size N x N , and each cell of this grid has a lamp that is initially turned off .
 You are also given an array of lamp positions lamps , where lamps [ i ] = [ row i , col i ] indicates that the lamp at grid [ row i ] [ col i ] is turned on . When a lamp is turned on , it illuminates its cell and all other cells in the same row , column , or diagonal .
 Finally , you are given a query array queries , where queries [ i ] = [ row i , col i ] . For the i th query , determine whether grid [ row i ] [ col i ] is illuminated or not . After answering the i th query , turn off the lamp at grid [ row i ] [ col i ] and its 8 adjacent lamps if they exist . A lamp is adjacent if its cell shares either a side or corner with grid [ row i ] [ col i ] .
 Given a 2D binary matrix filled with 0's and 1's , find the largest square containing only 1's and return its area .
 Your are given an array of positive integers nums .
 Given a m * n matrix mat and an integer K , return a matrix answer where each answer [ i ] [ j ] is the sum of all elements mat [ r ] [ c ] for i-K &lt; = r &lt; = i + K , j-K &lt; = c &lt; = j + K , and ( r , c ) is a valid position in the matrix .
 You are given coins of different denominations and a total amount of money . Write a function to compute the number of combinations that make up that amount . You may assume that you have infinite number of each kind of coin .
 In the " 100 game " two players take turns adding , to a running total , any integer from 1 to 10 . The player who first causes the running total to reach or exceed 100 wins .
 For example , two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &gt; = 100 .
 Given two integers maxChoosableInteger and desiredTotal , return true if the first player to move can force a win , otherwise return false . Assume both players play optimally .
 Now after pouring some non-negative integer cups of champagne , return how full the j th glass in the i th row is ( both i and j are 0-indexed . )
 Return the total cost to insert all elements from instructions into nums . Since the answer may be large , return it modulo 10 9 + 7
 You are given two strings s and t .
 Given a string s , return the minimum number of characters you need to delete to make s good .
 However , you can add any number of parenthesis at any position to change the priority of operations . You should find out how to add parenthesis to get the maximum result , and return the corresponding expression in string format . Your expression should NOT contain redundant parenthesis .
 However , the bold parenthesis in " 1000 / ( ( 100/10 ) / 2 ) " are redundant , since they don't influence the operation priority . So you should return " 1000 / ( 100 / 10/2 ) " .
 The length of the input array is [ 1 , 10 ] .
 Elements in the given array will be in range [ 2 , 1000 ] .
 Return true if it's possible to convert s into t in no more than k moves , otherwise return false .
 Input : s = " input " , t = " ouput " , k = 9
 Explanation : We need to shift each character in s one time to convert it into t . We can shift' a' to' b' during the 1st move . However , there is no way to shift the other characters in the remaining moves to obtain t from s.
 We are given a word list of unique words , each word is 6 letters long , and one word in this list is chosen as secret .
 This function returns an integer type , representing the number of exact matches ( value and position ) of your guess to the secret word . Also , if your guess is not in the given wordlist , it will return-1 instead .
 Besides the example test case below , there will be 5 additional test cases , each with 100 words in the word list . The letters of each word in those testcases were chosen independently at random from' a' to' z' , such that every word in the given word lists is unique .
 You are given n pairs of numbers . In every pair , the first number is always smaller than the second number .
 Given a set of pairs , find the length longest chain which can be formed . You needn't use up all the given pairs . You can select pairs in any order .
 The number of given pairs will be in the range [ 1 , 1000 ] .
 Explanation : The first three athletes got the top three highest scores , so they got " Gold Medal " , " Silver Medal " and " Bronze Medal " . For the left two athletes , you just need to output their relative ranks according to their scores .
 Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies . You must return the indices in increasing order .
 Given the root of a binary tree , return the sum of every tree node's tilt .
 Return the maximum number of edges you can remove , or return-1 if it's impossible for the graph to be fully traversed by Alice and Bob .
 Given a string s , return the length of the longest substring between two equal characters , excluding the two characters . If there is no such substring return-1 .
 Given a m * n matrix of ones and zeros , return how many square submatrices have all ones .
 Given an integer n , return true if it is a power of three . Otherwise , return false .
 Given a positive integer , return its corresponding column title as appear in an Excel sheet .
 For example , given the following triangle
 For a given n , a gray code sequence may not be uniquely defined .
 Given an array of integer coordinates queens that represents the positions of the Black Queens , and a pair of coordinates king that represent the position of the White King , return the coordinates of all the queens ( in any order ) that can attack the King .
 Given a list of folders , remove all sub-folders in those folders and return in any order the folders after removing .
 Returns the total number of occurrences for the given tweetName per minute , hour , or day ( depending on freq ) starting from the startTime ( in seconds ) and ending at the endTime ( in seconds ) .
 freq is always minute , hour or day , representing the time interval to get the total number of occurrences for the given tweetName .
 tweetCounts.getTweetCountsPerFrequency ( " minute " , " tweet3 " , 0 , 59 ) ; / / return [ 2 ] . The frequency is per minute ( 60 seconds ) , so there is one interval of time : 1 ) [ 0 , 60 &gt;-&gt; 2 tweets .
 tweetCounts.getTweetCountsPerFrequency ( " minute " , " tweet3 " , 0 , 60 ) ; / / return [ 2 , 1 ] . The frequency is per minute ( 60 seconds ) , so there are two intervals of time : 1 ) [ 0 , 60 &gt;-&gt; 2 tweets , and 2 ) [ 60,61 &gt;-&gt; 1 tweet .
 tweetCounts.getTweetCountsPerFrequency ( " hour " , " tweet3 " , 0 , 210 ) ; / / return [ 4 ] . The frequency is per hour ( 3600 seconds ) , so there is one interval of time : 1 ) [ 0 , 211 &gt;-&gt; 4 tweets .
 You are given an array coordinates , coordinates [ i ] = [ x , y ] , where [ x , y ] represents the coordinate of a point . Check if these points make a straight line in the XY plane .
 Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together . You may assume the given string consists of lowercase English letters only and its length will not exceed 10000 .
 There is a room with n lights which are turned on initially and 4 buttons on the wall . After performing exactly m unknown operations towards buttons , you need to return how many different kinds of status of the n lights could be .
 Suppose n lights are labeled as number [ 1 , 2 , 3 ... , n ] , function of these 4 buttons are given below :
 Given a Binary Search Tree ( BST ) with the root node root , return the minimum difference between the values of any two different nodes in the tree .
 The given tree [ 4,2,6,1,3 , null , null ] is represented by the following diagram :
 You are given a strictly increasing array arrival of positive integers , where arrival [ i ] represents the arrival time of the i th request , and another array load , where load [ i ] represents the load of the i th request ( the time it takes to complete ) . Your goal is to find the busiest server ( s ) . A server is considered busiest if it handled the most number of requests successfully among all the servers .
 Return a list containing the IDs ( 0-indexed ) of the busiest server ( s ) . You may return the IDs in any order .
 You may return the answer in any order . The answer is guaranteed to be unique ( except for the order that it is in . )
 You have a number of envelopes with widths and heights given as a pair of integers ( w , h ) . One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope .
 Find the sum of all left leaves in a given binary tree .
 Given a sequence of words written in the alien language , and the order of the alphabet , return true if and only if the given words are sorted lexicographicaly in this alien language .
 Given a list of sorted characters letters containing only lowercase letters , and given a target letter target , find the smallest element in the list that is larger than the given target .
 There are n engineers numbered from 1 to n and two arrays : speed and efficiency , where speed [ i ] and efficiency [ i ] represent the speed and efficiency for the i-th engineer respectively . Return the maximum performance of a team composed of at most k engineers , since the answer can be a huge number , return this modulo 10 ^ 9 + 7 .
 Given a positive integer n , return the n th term of the count-and-say sequence .
 You are playing a simplified PAC-MAN game on an infinite 2-D grid . You start at the point [ 0 , 0 ] , and you are given a destination point target = [ x target , y target ] , which you are trying to get to . There are several ghosts on the map with their starting positions given as an array ghosts , where ghosts [ i ] = [ x i , y i ] represents the starting position of the i th ghost . All inputs are integral coordinates .
 Return true if it is possible to escape , otherwise return false .
 Given the array arr of positive integers and the array queries where queries [ i ] = [ L i , R i ] , for each query i compute the XOR of elements from L i to Ri ( that is , arr [ L i ] xor arr [ L i +1 ] xor ... xor arr [ R i ] ) . Return an array containing the result for the given queries .
 Given two strings s and t , return the number of distinct subsequences of s which equals t .
 Given a data stream input of non-negative integers a 1 , a 2 , ... , a n , ... , summarize the numbers seen so far as a list of disjoint intervals .
 If there isn't any rectangle , return 0 .
 Since the answer may be too large , return it modulo 10 ^ 9 + 7 .
 You may assume that the given expression is always valid .
 Given the root of a tree , you are asked to find the most frequent subtree sum . The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node ( including the node itself ) . So what is the most frequent subtree sum value ? If there is a tie , return all the values with the highest frequency in any order .
 return [ 2 , -3 , 4 ] , since all the values happen only once , return all of them in any order .
 return [ 2 ] , since 2 happens twice , however -5 only occur once .
 Given a matrix of m x n elements ( m rows , n columns ) , return all elements of the matrix in spiral order .
 Given A and B , return the minimum number of swaps to make both sequences strictly increasing . It is guaranteed that the given input always makes it possible .
 For example , given the above Scores table , your query should generate the following report ( order by highest score ) :
 Given a sorted array of distinct integers and a target value , return the index if the target is found . If not , return the index where it would be if it were inserted in order .
 Return the roots of the trees in the remaining forest . You may return the result in any order .
 The number of nodes in the given tree is at most 1000 .
 / / getRandom should return 1 with the probability 2/3 , and returns 2 with the probability 1/3 .
 / / getRandom should return 1 and 2 both equally likely .
 Given the root of a binary tree , return an array of the largest value in each row of the tree ( 0-indexed ) .
 The directed graph has N nodes with labels 0 , 1 , ... , N-1 , where N is the length of graph . The graph is given in the following form : graph [ i ] is a list of labels j such that ( i , j ) is a directed edge of the graph .
 Given a string that contains only digits 0-9 and a target value , return all possibilities to add binary operators ( not unary ) + ,-, or * between the digits so they evaluate to the target value .
 In a given 2D binary array A , there are two islands . ( An island is a 4-directionally connected group of 1 s not connected to any other 1s . )
 We are given an array asteroids of integers representing asteroids in a row .
 Given 2 integers n and start . Your task is return any permutation p of ( 0,1,2 ..... ,2 ^ n -1 ) such that :
 lFUCache.get ( 1 ) ; / / return 1
 lFUCache.get ( 2 ) ; / / return -1 ( not found )
 lFUCache.get ( 3 ) ; / / return 3
 lFUCache.get ( 1 ) ; / / return -1 ( not found )
 lFUCache.get ( 3 ) ; / / return 3
 lFUCache.get ( 4 ) ; / / return 4
 Given an array of integers representing the data , return whether it is a valid utf-8 encoding .
 The input is an array of integers . Only the least significant 8 bits of each integer is used to store the data . This means each integer represents only 1 byte of data .
 int ping ( int t ) Adds a new request at time t , where t represents some time in milliseconds , and returns the number of requests that has happened in the past 3000 milliseconds ( including the new request ) . Specifically , return the number of requests that have happened in the inclusive range [ t-3000 , t ] .
 recentCounter.ping ( 1 ) ; / / requests = [ 1 ] , range is [-2999,1 ] , return 1
 recentCounter.ping ( 100 ) ; / / requests = [ 1 , 100 ] , range is [-2900,100 ] , return 2
 recentCounter.ping ( 3001 ) ; / / requests = [ 1 , 100 , 3001 ] , range is [ 1,3001 ] , return 3
 recentCounter.ping ( 3002 ) ; / / requests = [ 1 , 100 , 3001 , 3002 ] , range is [ 2,3002 ] , return 3
 A cycle is a path of length 4 or more in the grid that starts and ends at the same cell . From a given cell , you can move to one of the cells adjacent to it-in one of the four directions ( up , down , left , or right ) , if it has the same value of the current cell .
 Return true if any cycle of the same value exists in grid , otherwise , return false .
 If no such index exists , we should return -1 . If there are multiple pivot indexes , you should return the left-most pivot index .
 You are given the root node of a binary search tree ( BST ) and a value to insert into the tree . Return the root node of the BST after the insertion . It is guaranteed that the new value does not exist in the original BST .
 Notice that there may exist multiple valid ways for the insertion , as long as the tree remains a BST after insertion . You can return any of them .
 You need to help them find out their common interest with the least list index sum . If there is a choice tie between answers , output all of them with no order requirement . You could assume there always exists an answer .
 Write a function to compute the next state ( after one update ) of the board given its current state . The next state is created by applying the above rules simultaneously to every cell in the current state , where births and deaths occur simultaneously .
 Return an array containing the result for the given queries .
 Given an array nums of n integers where n &gt; 1 , return an array output such that output [ i ] is equal to the product of all the elements of nums except nums [ i ] .
 Could you solve it with constant space complexity ? ( The output array does not count as extra space for the purpose of space complexity analysis . )
 Return the kth string of this list or return an empty string if there are less than k happy strings of length n .
 Thus , we output the size of this set , which is 3 .
 Given a function f ( x , y ) and a value z , return all positive integer pairs x and y where f ( x , y ) == z .
 / / Returns positive integer f ( x , y ) for any given positive integer x and y.
 For custom testing purposes you're given an integer function_id and a target z as input , where function_id represent one function from an secret internal list , on the examples you'll know only two functions from the list .
 You may return the solutions in any order .
 Given an array points containing the coordinates of points on a 2D plane , sorted by the x-values , where points [ i ] = [ x i , y i ] such that x i &lt; x j for all 1 &lt; = i &lt; j &lt; = points.length . You are also given an integer k .
 Explanation : The first two points satisfy the condition | x i-x j | &lt; = 1 and if we calculate the equation we get 3 + 0 + | 1-2 | = 4 . Third and fourth points also satisfy the condition and give a value of 10 + -10 + | 5-6 | = 1 .
 No other pairs satisfy the condition , so we return the max of 4 and 1 .
 Explanation : Only the first two points have an absolute difference of 3 or less in the x-values , and give the value of 0 + 0 + | 0-3 | = 3 .
 HTML entity parser is the parser that takes HTML code as input and replace all the entities of the special characters by the characters itself .
 Given the input text string to the HTML parser , you have to implement the entity parser .
 The function twoSum should return indices of the two numbers such that they add up to the target , where index1 must be less than index2 .
 You may assume that each input would have exactly one solution and you may not use the same element twice .
 Given a string containing digits from 2-9 inclusive , return all possible letter combinations that the number could represent . Return the answer in any order .
 A mapping of digit to letters ( just like on the telephone buttons ) is given below . Note that 1 does not map to any letters .
 Given an integer N as input , return the number of' 1's in the first N number in the magical string S .
 Explanation : The first 6 elements of magical string S is " 12211 " and it contains three 1's , so return 3 .
 The given RPN expression is always valid . That means the expression would always evaluate to a result and there won't be any divide by zero operation .
 A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null .
 The Linked List is represented in the input / output as a list of n nodes . Each node is represented as a pair of [ val , random_index ] where :
 Explanation : Given linked list is empty ( null pointer ) , so return null .
 Since the result may be large , return the answer modulo 10 ^ 9 + 7 .
 Given an input string ( s ) and a pattern ( p ) , implement wildcard pattern matching with support for' ?' and' *' where :
 The matching should cover the entire input string ( not partial ) .
 There may be more than one LIS combination , it is only necessary for you to return the length .
 Note : The result may be very large , so you need to return a string instead of an integer .
 A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance . Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo ( Figure A ) , write a program to output the skyline formed by these buildings collectively ( Figure B ) .
 The output is a list of " key points " ( red dots in Figure B ) in the format of [ [ x1 , y1 ] , [ x2 , y2 ] , [ x3 , y3 ] , ... ] that uniquely defines a skyline . A key point is the left endpoint of a horizontal line segment . Note that the last key point , where the rightmost building ends , is merely used to mark the termination of the skyline , and always has zero height . Also , the ground in between any two adjacent buildings should be considered part of the skyline contour .
 The number of buildings in any input list is guaranteed to be in the range [ 0 , 10000 ] .
 The input list is already sorted in ascending order by the left x position Li .
 The output list must be sorted by the x position .
 There must be no consecutive horizontal lines of equal height in the output skyline . For instance , [ ... [ 2 3 ] , [ 4 5 ] , [ 7 5 ] , [ 11 5 ] , [ 12 7 ] ... ] is not acceptable ; the three lines of height 5 should be merged into one in the final output as such : [ ... [ 2 3 ] , [ 4 5 ] , [ 12 7 ] , ... ]
 You are given two non-empty linked lists representing two non-negative integers . The most significant digit comes first and each of their nodes contain a single digit . Add the two numbers and return it as a linked list .
 What if you can not modify the input lists ? In other words , reversing the lists is not allowed .
 Therefore the output is 7 .
 What if negative numbers are allowed in the given array ?
 Now you call peek ( ) and it returns 2 , the next element . Calling next ( ) after that still return 2 .
 Calling hasNext ( ) after that should return false .
 You are given K eggs , and you have access to a building with N floors from 1 to N .
 Each move , you may take an egg ( if you have an unbroken one ) and drop it from any floor X ( with 1 &lt; = X &lt; = N ) .
 Given an integer array A , and an integer target , return the number of tuples i , j , k such that i &lt; j &lt; k and A [ i ] + A [ j ] + A [ k ] == target .
 As the answer can be very large , return it modulo 10 9 + 7 .
 Given a string array words , find the maximum value of length ( word [ i ] ) * length ( word [ j ] ) where the two words do not share common letters . You may assume that each word will contain only lower case letters . If no such two words exist , return 0 .
 You are given a doubly linked list which in addition to the next and previous pointers , it could have a child pointer , which may or may not point to a separate doubly linked list . These child lists may have one or more children of their own , and so on , to produce a multilevel data structure , as shown in the example below .
 Flatten the list so that all the nodes appear in a single-level , doubly linked list . You are given the head of the first level of the list .
 The multilevel linked list in the input is as follows :
 The input multilevel linked list is as follows :
 Merging the serialization of each level and removing trailing nulls we obtain :
 Your output is the whole Person table after executing your sql . Use delete statement .
 You are given a sorted unique integer array nums .
 Each range [ a , b ] in the list should be output as :
 int get ( int key ) Return the value of the key if the key exists , otherwise return-1 .
 lRUCache.get ( 1 ) ; / / return 1
 lRUCache.get ( 1 ) ; / / return -1 ( not found )
 lRUCache.get ( 3 ) ; / / return 3
 lRUCache.get ( 4 ) ; / / return 4
 Given a string , find the first non-repeating character in it and return its index . If it doesn't exist , return -1 .
 return 0 .
 return 2 .
 You are given two arrays ( without duplicates ) nums1 and nums2 where nums1 â€™s elements are subset of nums2 . Find all the next greater numbers for nums1's elements in the corresponding places of nums2 .
 The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2 . If it does not exist , output -1 for this number .
 For number 4 in the first array , you can not find the next greater number for it in the second array , so output -1 .
 For number 2 in the first array , there is no next greater number for it in the second array , so output -1 .
 For number 4 in the first array , there is no next greater number for it in the second array , so output -1 .
 If there is no way to reach the target , return-1 .
 Return the length of the shortest such clear path from top-left to bottom-right . If such a path does not exist , return -1 .
 You need to return the number of important reverse pairs in the given array .
 The length of the given array will not exceed 50,000 .
 All the numbers in the input array are in the range of 32-bit integer .
 Suppose you are given the following code :
 The same instance of FooBar will be passed to two different threads . Thread A will call foo ( ) while thread B will call bar ( ) . Modify the given program to output " foobar " n times .
 Explanation : There are two threads being fired asynchronously . One of them calls foo ( ) , while the other calls bar ( ) . " foobar " is being output 1 time .
 Explanation : " foobar " is being output 2 times .
 Students can see the answers of those sitting next to the left , right , upper left and upper right , but he can not see the answers of the student sitting directly in front or behind him . Return the maximum number of students that can take the exam together without any cheating being possible . .
 Given a strictly increasing array A of positive integers forming a sequence , find the length of the longest fibonacci-like subsequence of A . If one does not exist , return 0 .
 Front : Get the front item from the queue . If the queue is empty , return -1 .
 Rear : Get the last item from the queue . If the queue is empty , return -1 .
 circularQueue.enQueue ( 1 ) ; / / return true
 circularQueue.enQueue ( 2 ) ; / / return true
 circularQueue.enQueue ( 3 ) ; / / return true
 circularQueue.enQueue ( 4 ) ; / / return false , the queue is full
 circularQueue.Rear ( ) ; / / return 3
 circularQueue.isFull ( ) ; / / return true
 circularQueue.deQueue ( ) ; / / return true
 circularQueue.enQueue ( 4 ) ; / / return true
 circularQueue.Rear ( ) ; / / return 4
 You may return the answer in any order . It is guaranteed an answer exists .
 Return a lucky integer in the array . If there are multiple lucky integers return the largest of them . If there is no lucky integer return-1 .
 Explanation : 1 , 2 and 3 are all lucky numbers , return the largest of them .
 Given two integers A and B , return any string S such that :
 It is guaranteed such an S exists for the given A and B .
 Given a positive 32-bit integer n , you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n . If no such positive 32-bit integer exists , you need to return -1 .
 At the beginning of the game , you start with an empty record . You are given a list of strings ops , where ops [ i ] is the i th operation you must apply to the record and is one of the following :
 Given an m x n matrix , return a new matrix answer where answer [ row ] [ col ] is the rank of matrix [ row ] [ col ] .
 It is guaranteed that answer is unique under the given rules .
 There are two kinds of threads , oxygen and hydrogen . Your goal is to group these threads to form water molecules . There is a barrier where each thread has to wait until a complete molecule can be formed . Hydrogen and oxygen threads will be given releaseHydrogen and releaseOxygen methods respectively , which will allow them to pass the barrier . These threads should pass the barrier in groups of three , and they must be able to immediately bond with each other to form a water molecule . You must guarantee that all the threads from one molecule bond before any other threads from the next molecule do .
 Total length of input string will be 3 n , where 1 â‰¤ n â‰¤ 20 .
 Total number of H will be 2 n in the input string .
 Total number of O will be n in the input string .
 Now , return answer , where answer [ x ] = y if y is the least quiet person ( that is , the person y with the smallest value of quiet [ y ] ) , among all people who definitely have equal to or more money than person x .
 We are given an array A of N lowercase letter strings , all of the same length .
 An undirected , connected graph of N nodes ( labeled 0 , 1 , 2 , ... , N-1 ) is given as graph .
 What if the given array is already sorted ? How would you optimize your algorithm ?
 Given a list of lists of integers , nums , return all elements of nums in diagonal order as shown in the below images .
 As the answer may be very large , return the answer modulo 10 ^ 9 + 7 .
 Given a positive integer n , find and return the longest distance between any two adjacent 1's in the binary representation of n . If there are no two adjacent 1's , return 0 .
 There aren't any adjacent pairs of 1's in the binary representation of 8 , so we return 0 .
 We are given head , the head node of a linked list containing unique integer values .
 We are also given the list G , a subset of the values in the linked list .
 If N is the length of the linked list given by head , 1 &lt; = N &lt; = 10000 .
 Given a list of 24-hour clock time points in " HH : MM " format , return the minimum minutes difference between any two time-points in the list .
 Explanation : We return the node with value 2 , colored in yellow in the diagram .
 Notice that nodes 5 , 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them , so we return it .
 For example , given nums = [ 2,1,3 ] , we will have 2 as the root , 1 as a left child , and 3 as a right child . The array [ 2,3,1 ] also yields the same BST but [ 3,2,1 ] yields a different BST .
 Since the answer may be very large , return it modulo 10 ^ 9 + 7 .
 The string " PAYPALISHIRING " is written in a zigzag pattern on a given number of rows like this : ( you may want to display this pattern in a fixed font for better legibility )
 Write the code that will take a string and make this conversion given a number of rows :
 Given a directed acyclic graph ( DAG ) of n nodes labeled from 0 to n-1 , find all possible paths from node 0 to node n-1 , and return them in any order .
 The graph is given as follows : graph [ i ] is a list of all nodes you can visit from node i ( i.e. , there is a directed edge from node i to node graph [ i ] [ j ] ) .
 The input graph is guaranteed to be a DAG .
 Return true if it is possible to transform string s into string t . Otherwise , return false .
 A single directory info string in the input list has the following format :
 The output is a list of group of duplicate file paths . For each group , it contains all the file paths of the files that have the same content . A file path is a string that has the following format :
 No order is required for the final output .
 The number of files given is in the range of [ 1,20000 ] .
 You may assume each given directory info represents a unique directory . Directory path and file info are separated by a single blank space .
 Imagine you are given a real file system , how will you search files ? DFS or BFS ?
 The length of the given binary array will not exceed 50,000 .
 If there are multiple answers , you may return any one of them . It is guaranteed an answer exists .
 Given two strings word1 and word2 , return the minimum number of operations required to convert word1 to word2 .
 You are given an array of distinct integers arr and an array of integer arrays pieces , where the integers in pieces are distinct . Your goal is to form arr by concatenating the arrays in pieces in any order . However , you are not allowed to reorder the integers in each array pieces [ i ] .
 Return true if it is possible to form the array arr from pieces . Otherwise , return false .
 Return the length of the longest uncommon subsequence between a and b . If the longest uncommon subsequence doesn't exist , return-1 .
 If searchWord is a prefix of more than one word , return the index of the first word ( minimum index ) . If there is no such word return-1 .
 Explanation : " pro " is prefix of " problem " which is the 2nd and the 6th word in the sentence , but we return 2 as it's the minimal index .
 You are given a perfect binary tree where all leaves are on the same level , and every parent has two children . The binary tree has the following definition :
 Explanation : Given the above perfect binary tree ( Figure A ) , your function should populate each next pointer to point to its next right node , just like in Figure B . The serialized output is in level order as connected by the next pointers , with' #' signifying the end of each level .
 The number of nodes in the given tree is less than 4096 .
 Given a sequence of integers , return the length of the longest subsequence that is a wiggle sequence . A subsequence is obtained by deleting some number of elements ( eventually , also zero ) from the original sequence , leaving the remaining elements in their original order .
 A web developer needs to know how to design a web page's size . So , given a specific rectangular web page â€™s area , your job by now is to design a rectangular web page , whose length L and width W satisfy the following requirements :
 The area of the rectangular web page you designed must equal to the given target area .
 Given a non-negative integer num , return the number of steps to reduce it to zero . If the current number is even , you have to divide it by 2 , otherwise , you have to subtract 1 from it .
 Step 1 ) 14 is even ; divide by 2 and obtain 7 .
 Step 2 ) 7 is odd ; subtract 1 and obtain 6 .
 Step 3 ) 6 is even ; divide by 2 and obtain 3 .
 Step 4 ) 3 is odd ; subtract 1 and obtain 2 .
 Step 5 ) 2 is even ; divide by 2 and obtain 1 .
 Step 6 ) 1 is odd ; subtract 1 and obtain 0 .
 Step 1 ) 8 is even ; divide by 2 and obtain 4 .
 Step 2 ) 4 is even ; divide by 2 and obtain 2 .
 Step 3 ) 2 is even ; divide by 2 and obtain 1 .
 Step 4 ) 1 is odd ; subtract 1 and obtain 0 .
 Given an integer array nums , return the maximum result of nums [ i ] XOR nums [ j ] , where 0 â‰¤ i â‰¤ j &lt; n .
 You are given a string s of even length consisting of digits from 0 to 9 , and two integers a and b .
 Return the lexicographically smallest string you can obtain by applying the above operations any number of times on s .
 There is no way to obtain a string that is lexicographically smaller then " 2050 " .
 There is no way to obtain a string that is lexicographically smaller then " 24 " .
 Explanation : There are no sequence of operations that will give us a lexicographically smaller string than " 0011 " .
 Notice that you can return the vertices in any order .
 Explanation : It's not possible to reach all the nodes from a single vertex . From 0 we can reach [ 0,1,2,5 ] . From 3 we can reach [ 3,4,2,5 ] . So we output [ 0,3 ] .
 Given a date , return the corresponding day of the week for that date .
 The input is given as three integers representing the day , month and year respectively .
 The given dates are valid dates between the years 1971 and 2100 .
 Explanation : Given the above binary tree ( Figure A ) , your function should populate each next pointer to point to its next right node , just like in Figure B . The serialized output is in level order as connected by the next pointers , with' #' signifying the end of each level .
 The number of nodes in the given tree is less than 6000 .
 For each call to the method MyCalendar.book , return true if the event can be added to the calendar successfully without causing a triple booking . Otherwise , return false and do not add the event to the calendar .
 You are given an n x n 2D matrix representing an image , rotate the image by 90 degrees ( clockwise ) .
 You have to rotate the image in-place , which means you have to modify the input 2D matrix directly . DO NOT allocate another 2D matrix and do the rotation .
 NOTE : input types have been changed on April 15 , 2019 . Please reset to default code definition to get new method signature .
 For a given query word , the spell checker handles two categories of spelling mistakes :
 When the query exactly matches a word in the wordlist ( case-sensitive ) , you should return the same word back .
 When the query matches a word up to capitlization , you should return the first such match in the wordlist .
 When the query matches a word up to vowel errors , you should return the first such match in the wordlist .
 If the query has no matches in the wordlist , you should return the empty string .
 Given some queries , return a list of words answer , where answer [ i ] is the correct word for query = queries [ i ] .
 Find the maximum width of a ramp in A . If one doesn't exist , return 0 .
 Given a valid ( IPv4 ) IP address , return a defanged version of that IP address .
 The given address is a valid IPv4 address .
 You are given an array of binary strings strs and two integers m and n .
 Find the length of the longest substring T of a given string ( consists of lowercase letters only ) such that every character in T appears no less than k times .
 So the final output is 4 .
 The two dates are given as strings , their format is YYYY-MM-DD as shown in the examples .
 The given dates are valid dates between the years 1971 and 2100 .
 In total , there is only one magic square inside the given grid .
 Given an integer k , return the minimum number of Fibonacci numbers whose sum is equal to k . The same Fibonacci number can be used multiple times .
 It is guaranteed that for the given constraints we can always find such Fibonacci numbers that sum up to k .
 Notice that we return an array of the chosen k values of the pancake flips .
 Explanation : The input is already sorted , so there is no need to flip anything .
 You are given an array of strings words and a string chars .
 Given an array positions where positions [ i ] = [ x i , y i ] is the position of the ith customer on the map , return the minimum sum of the euclidean distances to all customers .
 Return true if s is a valid string , otherwise , return false .
 Write a SQL solution to output big countries' name , population and area .
 For example , according to the above table , we should output :
 Given a rectangular pizza represented as a rows x cols matrix containing the following characters :' A' ( an apple ) and' .' ( empty cell ) and given the integer k . You have to cut the pizza into k pieces using k-1 cuts .
 For each cut you choose the direction : vertical or horizontal , then you choose a cut position at the cell boundary and cut the pizza into two pieces . If you cut the pizza vertically , give the left part of the pizza to a person . If you cut the pizza horizontally , give the upper part of the pizza to a person . Give the last piece of pizza to the last person .
 Return the number of ways of cutting the pizza such that each piece contains at least one apple . Since the answer can be a huge number , return this modulo 10 ^ 9 + 7 .
 You are given a string s , a split is called good if you can split s into 2 non-empty strings p and q where its concatenation is equal to s and the number of distinct letters in p and q are the same .
 Return the sum of the numbers from index left to index right ( indexed from 1 ) , inclusive , in the new array . Since the answer can be a huge number return it modulo 10 ^ 9 + 7 .
 Explanation : The given array is the same as example 1 . We have the new array [ 1 , 2 , 3 , 3 , 4 , 5 , 6 , 7 , 9 , 10 ] . The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6 .
 Given a binary tree , return the bottom-up level order traversal of its nodes' values . ( ie , from left to right , level by level from leaf to root ) .
 return its bottom-up level order traversal as :
 You will start from the point ( 0 , 0 ) and you should output the minimum steps you need to walk to cut off all the trees . If you can't cut off all the trees , output -1 in that situation .
 You are given n the number of rows of the grid .
 Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k .
 super ugly numbers given primes = [ 2,7,13,19 ] of size 4 .
 1 is a super ugly number for any given primes .
 The given numbers in primes are in ascending order .
 Given the string word , return the minimum total distance to type such string using only two fingers . The distance between coordinates ( x 1 , y 1 ) and ( x 2 , y 2 ) is | x 1-x 2 | + | y 1-y 2 | .
 input and output values are in floating-point .
 The input is two lists : the subroutines called and their arguments . Solution's constructor has three arguments , the radius , x-position of the center , and y-position of the center of the circle . randPoint has no arguments . Arguments are always wrapped with a list , even if there aren't any .
 In a given array nums of positive integers , find three non-overlapping subarrays with maximum sum .
 Return the result as a list of indices representing the starting position of each interval ( 0-indexed ) . If there are multiple answers , return the lexicographically smallest one .
 Since the result could be very large , you should return the largest palindrome mod 1337 .
 Given a puzzle board , return the least number of moves required so that the state of the board is solved . If it is impossible for the state of the board to be solved , return -1 .
 Your are given an array of integers prices , for which the i-th element is the price of a given stock on day i ; and a non-negative integer fee representing a transaction fee .
 The input numbers in binary are 0 , 01 , 011 ; which are 0 , 1 , and 3 in base-10 . Only the first number is divisible by 5 , so answer [ 0 ] is true .
 You are given an integer num . You will apply the following steps exactly two times :
 You are given two strings s1 and s2 of equal length consisting of letters " x " and " y " only . Your task is to make these two strings equal to each other . You can swap any two characters that belong to different strings , which means : swap s1 [ i ] and s2 [ j ] .
 Return the minimum number of swaps required to make s1 and s2 equal , or return-1 if it is impossible to do so .
 Explanation : Almost the same as the first example , except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output .
 We are given the head node root of a binary tree , where additionally every node's value is either a 0 or a 1 .
 Return the same tree where every subtree ( of the given tree ) not containing a 1 has been removed .
 Return the minimum number of moves to transform the given array nums into a zigzag array .
 Given the integer n and the array roads , return the maximal network rank of the entire infrastructure .
 You are a hiker preparing for an upcoming hike . You are given heights , a 2D array of size rows x columns , where heights [ row ] [ col ] represents the height of cell ( row , col ) . You are situated in the top-left cell , ( 0 , 0 ) , and you hope to travel to the bottom-right cell , ( rows-1 , columns-1 ) ( i.e. , 0-indexed ) . You can move up , down , left , or right , and you wish to find a route that requires the minimum effort .
 You are given a list of non-negative integers , a1 , a2 , ... , an , and a target , S . Now you have 2 symbols + and-. For each integer , you should choose one from + and-as its new symbol .
 The length of the given array is positive and will not exceed 20 .
 The sum of elements in the given array will not exceed 1000 .
 Your output answer is guaranteed to be fitted in a 32-bit integer .
 You are given an array representing a row of seats where seats [ i ] = 1 represents a person sitting in the i th seat , and seats [ i ] = 0 represents that the i th seat is empty ( 0-indexed ) .
 Your script should output the following , sorted by descending frequency :
 Splitting into two or more chunks will not return the required result .
 You are given a data structure of employee information , which includes the employee's unique id , their importance value and their direct subordinates' id .
 Now given the employee information of a company , and an employee id , you need to return the total importance value of this employee and all their subordinates .
 Return any binary tree that matches the given preorder and postorder traversals .
 It is guaranteed an answer exists . If there exists multiple answers , you can return any of them .
 Write a function to delete a node in a singly-linked list . You will not be given access to the head of the list , instead you will be given access to the node to be deleted directly .
 Explanation : You are given the second node with value 5 , the linked list should become 4-&gt; 1-&gt; 9 after calling your function .
 Explanation : You are given the third node with value 1 , the linked list should become 4-&gt; 5-&gt; 9 after calling your function .
 The number of the nodes in the given list is in the range [ 2 , 1000 ] .
 You are given a string expression representing a Lisp-like expression to return the integer value of .
 The syntax for these expressions is given as follows .
 The given string expression is well formatted : There are no leading or trailing spaces , there is only a single space separating different components of the string , and no space between adjacent parentheses . The expression is guaranteed to be legal and evaluate to an integer .
 Given an integer array arr , return the mean of the remaining integers after removing the smallest 5 % and the largest 5 % of the elements .
 We start at the source square and want to reach the target square . Each move , we can walk to a 4-directionally adjacent square in the grid that isn't in the given list of blocked squares .
 Given an array A of integers , return the number of ( contiguous , non-empty ) subarrays that have a sum divisible by K .
 All input integers will range from 0 to 100 .
 Input points have NO order . No order required for output .
 input types have been changed on April 15 , 2019 . Please reset to default code definition to get new method signature .
 Given an array of integers nums and an integer k , return the number of unique k-diff pairs in the array .
 Although we have two 1s in the input , we should only return the number of unique pairs .
 Given an array of integers arr , return true if and only if it is a valid mountain array .
 Given the string croakOfFrogs , which represents a combination of the string " croak " from different frogs , that is , multiple frogs can croak at the same time , so multiple â€œ croak â€ are mixed . Return the minimum number of different frogs to finish all the croak in the given string .
 A valid " croak " means a frog is printing 5 letters â€˜ c â€™ , â€™ r â€™ , â€™ o â€™ , â€™ a â€™ , â€™ k â€™ sequentially . The frogs have to print all five letters to finish a croak . If the given string is not a combination of valid " croak " return -1 .
 Explanation : The given string is an invalid combination of " croak " from different frogs .
 For example , given
 You are given an array of network towers towers and an integer radius , where towers [ i ] = [ x i , y i , q i ] denotes the i th network tower with location ( x i , y i ) and quality factor q i . All the coordinates are integral coordinates on the X-Y plane , and the distance between two coordinates is the Euclidean distance .
 Return the integral coordinate where the network quality is maximum . If there are multiple coordinates with the same network quality , return the lexicographically minimum coordinate .
 Return the minimum number of boats to carry every given person . ( It is guaranteed each person can be carried by a boat . )
 If the number is divisible by 3 , output " fizz " .
 If the number is divisible by 5 , output " buzz " .
 If the number is divisible by both 3 and 5 , output " fizzbuzz " .
 For example , for n = 15 , we output : 1 , 2 , fizz , 4 , buzz , fizz , 7 , 8 , fizz , buzz , 11 , fizz , 13 , 14 , fizzbuzz .
 Suppose you are given the following code :
 public void fizz ( printFizz ) { ... } / / only output " fizz "
 public void buzz ( printBuzz ) { ... } / / only output " buzz "
 public void fizzbuzz ( printFizzBuzz ) { ... } / / only output " fizzbuzz "
 public void number ( printNumber ) { ... } / / only output the numbers
 Thread D will call number ( ) which should only output the numbers .
 Given the root of a binary tree , return the length of the longest path , where each node in the path has the same value . This path may or may not pass through the root .
 We are given a list nums of integers representing a list compressed with run-length encoding .
 Given a positive integer n , return the number of all possible attendance records with length n , which will be regarded as rewardable . The answer may be very large , return it after mod 10 9 + 7 .
 MajorityChecker ( int [ ] arr ) constructs an instance of MajorityChecker with the given array arr ;
 So you should return 1 because there is only one bulb is on .
 Given an array of n positive integers and a positive integer s , find the minimal length of a contiguous subarray of which the sum â‰¥ s . If there isn't one , return 0 instead .
 You are given a target value to search . If found in the array return true , otherwise return false .
 You are given an array of variable pairs equations and an array of real numbers values , where equations [ i ] = [ A i , B i ] and values [ i ] represent the equation A i / B i = values [ i ] . Each A i or B i is a string that represents a single variable .
 You are also given some queries , where queries [ j ] = [ C j , D j ] represents the j th query where you must find the answer for C j / D j = ? .
 Return the answers to all queries . If a single answer can not be determined , return-1.0 .
 Note : The input is always valid . You may assume that evaluating the queries will not result in division by zero and that there is no contradiction .
 return : [ 6.0 , 0.5 , -1.0 , 1.0 , -1.0 ]
 You are given an integer array prices where prices [ i ] is the price of a given stock on the i th day .
 We are given a list A of strings . Every string in A is an anagram of every other string in A . How many groups are there ?
 Given a string s , return the maximum number of unique substrings that the given string can be split into .
 We would like to write an expression with the least number of operators such that the expression equals the given target . Return the least number of operators used .
 Given such a binary tree , you need to output the second minimum value in the set made of all the nodes' value in the whole tree .
 If no such second minimum value exists , output -1 instead .
 You are given an array x of n positive numbers . You start at point ( 0,0 ) and moves x [ 0 ] metres to the north , then x [ 1 ] metres to the west , x [ 2 ] metres to the south , x [ 3 ] metres to the east and so on . In other words , after each move your direction changes counter-clockwise .
 You are given a square board of characters . You can move on the board starting at the bottom right square marked with the character' S' .
 Return a list of two integers : the first integer is the maximum sum of numeric characters you can collect , and the second is the number of such paths that you can take to get that maximum sum , taken modulo 10 ^ 9 + 7 .
 In case there is no path , return [ 0 , 0 ] .
 Given a string and a string dictionary , find the longest string in the dictionary that can be formed by deleting some characters of the given string . If there are more than one possible results , return the longest word with the smallest lexicographical order . If there is no possible result , return the empty string .
 All the strings in the input will only contain lower-case letters .
 The length of all the strings in the input won't exceed 1,000 .
 Given an integer array nums , return the number of longest increasing subsequences .
 Explanation : The length of longest continuous increasing subsequence is 1 , and there are 5 subsequences' length is 1 , so output 5 .
 Your task is to obtain the configuration represented by target where target [ i ] is' 1' if the i-th bulb is turned on and is' 0' if it is turned off .
 Now given a string represented by several bits . Return whether the last character must be a one-bit character or not . The given string will always end with a zero .
 Can you write a SQL query to output the result for Mary ?
 For the sample input , the output is :
 Return the minimum number of pushes to move the box to the target . If there is no way to reach the target , return-1 .
 Explanation : We return only the number of times the box is pushed .
 We are given an array A of N lowercase letter strings , all of the same length .
 The input array has a degree of 2 because both elements 1 and 2 appear twice .
 The shortest length is 2 . So return 2 .
 For example , given
 Given a string s of zeros and ones , return the maximum score after splitting the string into two non-empty substrings ( i.e. left substring and right substring ) .
 Given an integer array arr that is guaranteed to be a mountain , return any i such that arr [ 0 ] &lt; arr [ 1 ] &lt; ... arr [ i-1 ] &lt; arr [ i ] &gt; arr [ i + 1 ] &gt; ... &gt; arr [ arr.length-1 ] .
 Given an integer array nums , return the number of range sums that lie in [ lower , upper ] inclusive .
 You may assume the tree ( i.e. , the given root node ) is not NULL .
 There are a total of numCourses courses you have to take , labeled from 0 to numCourses-1 .
 Some courses may have prerequisites , for example to take course 0 you have to first take course 1 , which is expressed as a pair : [ 0,1 ]
 Explanation : There are a total of 2 courses to take .
 To take course 1 you should have finished course 0 . So it is possible .
 Explanation : There are a total of 2 courses to take .
 To take course 1 you should have finished course 0 , and to take course 0 you should
 The input prerequisites is a graph represented by a list of edges , not adjacency matrices . Read more about how a graph is represented .
 You may assume that there are no duplicate edges in the input prerequisites .
 There is a pizza with 3n slices of varying size , you and your friends will take slices of pizza as follows :
 We are given a list of ( axis-aligned ) rectangles . Each rectangle [ i ] = [ x1 , y1 , x2 , y2 ] , where ( x1 , y1 ) are the coordinates of the bottom-left corner , and ( x2 , y2 ) are the coordinates of the top-right corner of the i th rectangle .
 Find the total area covered by all rectangles in the plane . Since the answer may be too large , return it modulo 10 ^ 9 + 7 .
 You are given an integer array nums and you have to return a new counts array . The counts array has the property where counts [ i ] is the number of smaller elements to the right of nums [ i ] .
 Return the array of restaurant IDs after filtering , ordered by rating from highest to lowest . For restaurants with the same rating , order them by id from highest to lowest . For simplicity veganFriendly i and veganFriendly take value 1 when it is true , and 0 when it is false .
 Given the root of a binary tree , return the inorder traversal of its nodes' values .
 Given an array of integers nums and an integer k , return the total number of continuous subarrays whose sum equals to k .
 Given a string s containing only digits , return all possible valid IP addresses that can be obtained from s . You can return them in any order .
 Given an integer array nums , in which exactly two elements appear only once and all the other elements appear exactly twice . Find the two elements that appear only once . You can return the answer in any order .
 You are given an array of intervals , where intervals [ i ] = [ start i , end i ] and each start i is unique .
 You are given an integer array , inventory , where inventory [ i ] represents the number of balls of the i th color that you initially own . You are also given an integer orders , which represents the total number of balls that the customer wants . You can sell the balls in any order .
 Return the maximum total value that you can attain after selling orders colored balls . As the answer may be too large , return it modulo 10 9 + 7 .
 You are given a string keysPressed of length n , where keysPressed [ i ] was the i th key pressed in the testing sequence , and a sorted list releaseTimes , where releaseTimes [ i ] was the time the i th key was released . Both arrays are 0-indexed . The 0 th key was pressed at the time 0 , and every subsequent key was pressed at the exact time the previous key was released .
 Return the key of the keypress that had the longest duration . If there are multiple such keypresses , return the lexicographically largest key of the keypresses .
 Given the label of a node in this tree , return the labels in the path from the root of the tree to the node with that label .
 Say you have an array for which the i th element is the price of a given stock on day i .
 A robot on an infinite grid starts at point ( 0 , 0 ) and faces north . The robot can receive one of three possible types of commands :
 Find all the critical and pseudo-critical edges in the minimum spanning tree ( MST ) of the given graph . An MST edge whose deletion from the graph would cause the MST weight to increase is called a critical edge . A pseudo-critical edge , on the other hand , is that which can appear in some MSTs but not all .
 Note that you can return the indices of the edges in any order .
 Notice that the two edges 0 and 1 appear in all MSTs , therefore they are critical edges , so we return them in the first list of the output .
 The edges 2 , 3 , 4 , and 5 are only part of some MSTs , therefore they are considered pseudo-critical edges . We add them to the second list of the output .
 Explanation : We can observe that since all 4 edges have equal weight , choosing any 3 edges from the given 4 will yield an MST . Therefore all 4 edges are pseudo-critical .
 Given a square matrix mat , return the sum of the matrix diagonals .
 Return the string after making it good . The answer is guaranteed to be unique under the given constraints .
 Given a chemical formula ( given as a string ) , return the count of each atom .
 Given a formula , return the count of all elements as a string in the following form : the first name ( in sorted order ) , followed by its count ( if that count is more than 1 ) , followed by the second name ( in sorted order ) , followed by its count ( if that count is more than 1 ) , and so on .
 Now , given two positive integers L and R ( represented as strings ) , return the number of superpalindromes in the inclusive range [ L , R ] .
 If it is possible , return any [ i , j ] with i +1 &lt; j , such that :
 If it is not possible , return [-1 , -1 ] .
 Given the root of a binary tree , return the lowest common ancestor of its deepest leaves .
 Explanation : We return the node with value 2 , colored in yellow in the diagram .
 Given two strings S and T , each of which represents a non-negative rational number , return True if and only if they represent the same number . The strings may use parentheses to denote the repeating part of the rational number .
 The couples' initial seating is given by row [ i ] being the value of the person who is initially sitting in the i-th seat .
 Since the answer may be too large , return it modulo 10 ^ 9 + 7 .
 Given a binary matrix A , we want to flip the image horizontally , then invert it , and return the resulting image .
 You are given an array nums of non-negative integers . nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x .
 Return x if the array is special , otherwise , return-1 . It can be proven that if nums is special , the value for x is unique .
 There are several cards arranged in a row , and each card has an associated number of points The points are given in the integer array cardPoints .
 In one step , you can take one card from the beginning or from the end of the row . You have to take exactly k cards .
 Given the integer array cardPoints and the integer k , return the maximum score you can obtain .
 Explanation : After the first step , your score will always be 1 . However , choosing the rightmost card first will maximize your total score . The optimal strategy is to take the three cards on the right , giving a final score of 1 + 6 + 5 = 12 .
 Explanation : Regardless of which two cards you take , your score will always be 4 .
 Explanation : You have to take all the cards . Your score is the sum of points of all cards .
 Explanation : You can not take the card in the middle . Your best score is 1 .
 Return the length of N . If there is no such N , return -1 .
 We write the integers of A and B ( in the order they are given ) on two separate horizontal lines .
 You are given a list of preferences for n friends , where n is always even .
 All the friends are divided into pairs . The pairings are given in a list pairs , where pairs [ i ] = [ x i , y i ] denotes x i is paired with y i and y i is paired with x i .
 We are given a string S of' 0' s and' 1' s , and we may flip any' 0' to a' 1' or a' 1' to a' 0' .
 Given the initial state of the prison , return the state of the prison after N days ( and N such changes described above . )
 You are given a m x n matrix targetGrid , where targetGrid [ row ] [ col ] is the color in the position ( row , col ) of the grid .
 Return true if it is possible to print the matrix targetGrid , otherwise , return false .
 For example , given the above Employee table , the n th highest salary where n = 2 is 200 . If there is no n th highest salary , then the query should return null .
 Construct the maximum tree by the given array and output the root node of this tree .
 Output : return the tree root node representing the following tree :
 The size of the given array will be in the range [ 1,1000 ] .
 Return the largest sum of the given array after partitioning .
 Given an integer array nums , return the sum of divisors of the integers in that array that have exactly four divisors .
 If there is no such integer in the array , return 0 .
 undergroundSystem.getAverageTime ( " Paradise " , " Cambridge " ) ; / / return 14.00000 . There was only one travel from " Paradise " ( at time 8 ) to " Cambridge " ( at time 22 )
 undergroundSystem.getAverageTime ( " Leyton " , " Waterloo " ) ; / / return 11.00000 . There were two travels from " Leyton " to " Waterloo " , a customer with id = 45 from time = 3 to time = 15 and a customer with id = 27 from time = 10 to time = 20 . So the average time is ( ( 15-3 ) + ( 20-10 ) ) / 2 = 11.00000
 undergroundSystem.getAverageTime ( " Leyton " , " Waterloo " ) ; / / return 11.00000
 undergroundSystem.getAverageTime ( " Leyton " , " Waterloo " ) ; / / return 12.00000
 undergroundSystem.getAverageTime ( " Leyton " , " Paradise " ) ; / / return 5.00000
 undergroundSystem.getAverageTime ( " Leyton " , " Paradise " ) ; / / return 5.50000
 undergroundSystem.getAverageTime ( " Leyton " , " Paradise " ) ; / / return 6.66667
 What is the smallest number that is good ? If no number is good , output 0 .
 numArray.sumRange ( 0 , 2 ) ; / / return 1 ( (-2 ) + 0 + 3 )
 numArray.sumRange ( 2 , 5 ) ; / / return -1 ( 3 + (-5 ) + 2 + (-1 ) )
 numArray.sumRange ( 0 , 5 ) ; / / return -3 ( (-2 ) + 0 + 3 + (-5 ) + 2 + (-1 ) )
 Return True if it is possible to construct the target array from A otherwise return False .
 Follow-up : Can you implement the queue such that each operation is amortized O ( 1 ) time complexity ? In other words , performing n operations will take overall O ( n ) time even if one of those operations may take longer .
 myQueue.peek ( ) ; / / return 1
 myQueue.pop ( ) ; / / return 1 , queue is [ 2 ]
 myQueue.empty ( ) ; / / return false
 Given an array A of positive integers ( not necessarily distinct ) , return the lexicographically largest permutation that is smaller than A , that can be made with one swap ( A swap exchanges the positions of two numbers A [ i ] and A [ j ] ) . If it can not be done , then return the same array .
 Say you have an array for which the i th element is the price of a given stock on day i .
 In LOL world , there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition . Now , given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking , you need to output the total time that Ashe is in poisoned condition .
 So you finally need to output 4 .
 So you finally need to output 3 .
 You may assume the length of given time series array won't exceed 10000 .
 Return any solution if there is more than one solution and return an empty list if there is no solution .
 We are given N different types of stickers . Each sticker has a lowercase English word on it .
 You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them .
 What is the minimum number of stickers that you need to spell out the target ? If the task is impossible , return -1 .
 Explanation : We can't form the target " basicbasic " from cutting letters from the given stickers .
 The relative order inside both the even and odd groups should remain as it was in the input .
 Return the minimum number of steps to make the given string empty .
 A string is a subsequence of a given string , if it is generated by deleting some characters of a given string without changing its order .
 Your task is to remove the minimum number of parentheses (' (' or' )' , in any positions ) so that the resulting parentheses string is valid and return any valid string .
 Given an integer array nums , return the length of its longest harmonious subsequence among all its possible subsequences .
 int getIndex ( idx ) Gets the current value at index idx ( 0-indexed ) of the sequence modulo 10 9 + 7 . If the index is greater or equal than the length of the sequence , return-1 .
 fancy.getIndex ( 0 ) ; / / return 10
 fancy.getIndex ( 0 ) ; / / return 26
 fancy.getIndex ( 1 ) ; / / return 34
 fancy.getIndex ( 2 ) ; / / return 20
 The compressed string s should not be returned separately , but instead be stored in the input character array chars . Note that group lengths that are 10 or longer will be split into multiple characters in chars .
 After you are done modifying the input array , return the new length of the array .
 Output : Return 6 , and the first 6 characters of the input array should be : [ " a " , " 2 " , " b " , " 2 " , " c " , " 3 " ]
 Output : Return 1 , and the first character of the input array should be : [ " a " ]
 Output : Return 4 , and the first 4 characters of the input array should be : [ " a " , " b " , " 1 " , " 2 " ] .
 Output : Return 6 , and the first 6 characters of the input array should be : [ " a " , " 3 " , " b " , " 2 " , " a " , " 2 " ] .
 Given the head of a linked list , remove the n th node from the end of the list and return its head .
 Given the height m and the length n of a m * n Multiplication Table , and a positive integer k , you need to return the k-th smallest number in this table .
 How would you handle overflow for very large input integers ?
 We are given the root of a binary tree with unique values , and the values x and y of two different nodes in the tree .
 Given a parentheses string , return the minimum number of parentheses we must add to make the resulting string valid .
 Given a binary tree , return the vertical order traversal of its nodes values .
 The node with value 5 and the node with value 6 have the same position according to the given scheme .
 There are a total of n courses you have to take , labeled from 0 to n-1 .
 Some courses may have direct prerequisites , for example , to take course 0 you have first to take course 1 , which is expressed as a pair : [ 1,0 ]
 Return a list of boolean , the answers to the given queries .
 Take the top card of the deck , reveal it , and take it out of the deck .
 You are given a string s , return the number of segments in the string .
 Explanation : The input board is shown above and the only valid solution is shown below :
 It is guaranteed that the input board has only one solution .
 So we return the level with the maximum sum which is level 2 .
 We are given a personal information string S , which may represent either an email address or a phone number .
 Any given bucket can be sampled an infinite number of times ( by an unlimited number of pigs ) .
 return its depth = 3 .
 For example , in the given tree above , the leaf value sequence is ( 6 , 7 , 4 , 9 , 8 ) .
 Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar .
 Both of the given trees will have values in the range [ 0 , 200 ] .
 At each node in this traversal , we output D dashes ( where D is the depth of this node ) , then we output the value of this node . If the depth of a node is D , the depth of its immediate child is D + 1 . The depth of the root node is 0 .
 Given the output S of this traversal , recover the tree and return its root .
 Given an integer array arr and an integer difference , return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference .
 Return the maximum sum of Like-time coefficient that the chef can obtain after dishes preparation .
 After doing so , return the array .
 If there is no non-empty subarray with sum at least K , return-1 .
 The input / output represents the serialized format of a Quad-Tree using level order traversal , where null signifies a path terminator where no node exists below .
 Given n boxes , each box is given in the format [ status , candies , keys , containedBoxes ] where :
 You will start with some boxes given in initialBoxes array . You can take all the candies in any open box and you can use the keys in it to open new boxes and you also can use the boxes you find in it .
 Explanation : You will be initially given box 0 . You will find 7 candies in it and boxes 1 and 2 . Box 1 is closed and you don't have a key for it so you will open box 2 . You will find 4 candies and a key to box 1 in box 2 .
 Your function should return true if any value appears at least twice in the array , and it should return false if every element is distinct .
 We are given non-negative integers nums [ i ] which are written on a chalkboard . Alice and Bob take turns erasing exactly one number from the chalkboard , with Alice starting first . If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0 , then that player loses . ( Also , we'll say the bitwise XOR of one element is that element itself , and the bitwise XOR of no elements is 0 . )
 Given a non-empty string containing an out-of-order English representation of digits 0-9 , output the digits in ascending order .
 The given array size will in the range [ 2 , 10000 ] .
 The given array's numbers won't have any order .
 Given an n-ary tree , return the preorder traversal of its nodes' values .
 Nary-Tree input serialization is represented in their level order traversal , each group of children is separated by the null value ( See examples ) .
 Winston was given the above mysterious function func . He has an integer array arr and an integer target and he wants to find the values l and r that make the value | func ( arr , l , r )-target | minimum possible .
 Given a mountain array mountainArr , return the minimum index such that mountainArr.get ( index ) == target . If such an index doesn't exist , return-1 .
 Explanation : 3 does not exist in the array , so we return -1 .
 Given a list of emails , we send one email to each address in the list . How many different addresses actually receive mails ?
 Explanation : " testemail@leetcode.com " and "testemail@lee.tcode.com " actually receive mails
 ( Here , the given index = queries [ i ] [ 1 ] is a 0-based index , and each query permanently modifies the array A . )
 Write a SQL query to find employees who earn the top three salaries in each of the department . For the above tables , your SQL query should return the following rows ( order of rows does not matter ) .
 You may assume all input has valid answer .
 You are given a sorted array consisting of only integers where every element appears exactly twice , except for one element which appears exactly once . Find this single element that appears only once .
 You write down a secret number and ask your friend to guess what the number is . When your friend makes a guess , you provide a hint with the following info :
 Given the secret number secret and your friend's guess guess , return the hint for your friend's guess .
 Given an array of integers A with even length , return true if and only if it is possible to reorder it such that A [ 2 * i + 1 ] = 2 * A [ 2 * i ] for every 0 &lt; = i &lt; len ( A ) / 2 .
 Explanation : We can take two groups , [-2,-4 ] and [ 2,4 ] to form [-2,-4,2,4 ] or [ 2,4,-2,-4 ] .
 Given a square at location ( r0 , c0 ) in the grid and a color , color the border of the connected component of that square with the given color , and return the final grid .
 We then give 1 candy to the first person , 2 candies to the second person , and so on until we give n candies to the last person .
 Then , we go back to the start of the row , giving n + 1 candies to the first person , n + 2 candies to the second person , and so on until we give 2 * n candies to the last person .
 This process repeats ( with us giving one more candy each time , and moving to the start of the row after we reach the end ) until we run out of candies . The last person will receive all of our remaining candies ( not necessarily one more than the previous gift ) .
 Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array .
 such that arr [ i ] &lt; arr [ j ] &lt; arr [ k ] given 0 â‰¤ i &lt; j &lt; k â‰¤ n-1 else return false .
 Given a list of unique words , return all the pairs of the distinct indices ( i , j ) in the given list , so that the concatenation of the two words words [ i ] + words [ j ] is a palindrome .
 What is the length of the shortest reference string S possible that encodes the given words ?
 Given two binary strings , return their sum ( also a binary string ) .
 The input strings are both non-empty and contains only characters 1 or 0 .
 You are given a binary tree in which each node contains an integer value .
 Find the number of paths that sum to a given value .
 There is an m by n grid with a ball . Given the start coordinate ( i , j ) of the ball , you can move the ball to adjacent cell or cross the grid boundary in four directions ( up , down , left , right ) . However , you can at most move N times . Find out the number of paths to move the ball out of grid boundary . The answer may be very large , return it after mod 10 9 + 7 .
 The number of ways could be very large so return it modulo 10 ^ 9 + 7
 You are given an array A of strings .
 If possible , output any possible result . If not possible , return the empty string .
 Given a number N , return a string consisting of " 0 " s and " 1 " s that represents its value in base-2 ( negative two ) .
 Find the maximum area of an island in the given 2D array . ( If there is no island , the maximum area is 0 . )
 Given the above grid , return 6 . Note the answer is not 11 , because the island must be connected 4-directionally .
 Given the above grid , return 0 .
 Note : The length of each dimension in the given grid does not exceed 50 .
 Given an array nums of n integers and an integer target , find three integers in nums such that the sum is closest to target . Return the sum of the three integers . You may assume that each input would have exactly one solution .
 Given an array A of positive lengths , return the largest perimeter of a triangle with non-zero area , formed from 3 of these lengths .
 If it is impossible to form any triangle of non-zero area , return 0 .
 Return true if the array can be rearranged to form an arithmetic progression , otherwise , return false .
 Explanation : There is no way to reorder the elements to obtain an arithmetic progression .
 Given N , return any beautiful array A . ( It is guaranteed that one exists . )
 You are given a string s containing lowercase letters and an integer k . You need to :
 mapSum.sum ( " ap " ) ; / / return 3 ( ap ple = 3 )
 mapSum.sum ( " ap " ) ; / / return 5 ( ap ple + ap p = 3 + 2 = 5 )
 Given a binary tree , return the sum of values of its deepest leaves .
 Solve a given equation and return the value of x in the form of string " x = #value " . The equation contains only' +' ,'-' operation , the variable x and its coefficient .
 If there is no solution for the equation , return " No solution " .
 If there are infinite solutions for the equation , return " Infinite solutions " .
 You are given row x col grid representing a map where grid [ i ] [ j ] = 1 represents land and grid [ i ] [ j ] = 0 represents water .
 You are given two images img1 and img2 both of size n x n , represented as binary , square matrices of the same size . ( A binary matrix has only 0s and 1s as values . )
 You may return the final list of trees in any order .
 Find the minimum cost to merge all piles of stones into one pile . If it is impossible , return-1 .
 A string S of lowercase English letters is given . We want to partition this string into as many parts as possible so that each letter appears in at most one part , and return a list of integers representing the size of these parts .
 Given a flowerbed ( represented as an array containing 0 and 1 , where 0 means empty and 1 means not empty ) , and a number n , return if n new flowers can be planted in it without violating the no-adjacent-flowers rule .
 The input array won't violate no-adjacent-flowers rule .
 The input array size is in the range of [ 1 , 20000 ] .
 n is a non-negative integer which won't exceed the input array size .
 Given an n-ary tree , return the level order traversal of its nodes' values .
 Nary-Tree input serialization is represented in their level order traversal , each group of children is separated by the null value ( See examples ) .
 Given a string s which consists of lowercase or uppercase letters , return the length of the longest palindrome that can be built with those letters .
 Given an array A of non-negative integers , return the maximum sum of elements in two non-overlapping ( contiguous ) subarrays , which have lengths L and M . ( For clarification , the L-length subarray could occur before or after the M-length subarray . )
 Formally , return the largest V for which V = ( A [ i ] + A [ i +1 ] + ... + A [ i + L-1 ] ) + ( A [ j ] + A [ j +1 ] + ... + A [ j + M-1 ] ) and either :
 Note that you only take a snake or ladder at most once per move : if the destination to a snake or ladder is the start of another snake or ladder , you do not continue moving . ( For example , if the board is ` [ [ 4,-1 ] , [-1,3 ] ] ` , and on the first move your destination square is ` 2 ` , then you finish your first move at ` 3 ` , because you do not continue moving to ` 4 ` . )
 Return the least number of moves required to reach square N * N . If it is not possible , return-1 .
 You decide to move to square 2 , and must take the ladder to square 15 .
 You then decide to move to square 17 ( row 3 , column 5 ) , and must take the snake to square 13 .
 You then decide to move to square 14 , and must take the ladder to square 35 .
 A query word matches a given pattern if we can insert lowercase letters to the pattern word so that it equals the query . ( We may insert each character at any position , and may insert 0 characters . )
 Given a list of queries , and a pattern , return an answer list of booleans , where answer [ i ] is true if and only if queries [ i ] matches the pattern .
 Return True if the circle and rectangle are overlapped otherwise return False .
 The given input is a directed graph that started as a rooted tree with N nodes ( with distinct values 1 , 2 , ... , N ) , with one additional directed edge added . The added edge has two different vertices chosen from 1 to N , and was not an edge that already existed .
 The resulting graph is given as a 2D-array of edges . Each element of edges is a pair [ u , v ] that represents a directed edge connecting nodes u and v , where u is a parent of child v .
 Return an edge that can be removed so that the resulting graph is a rooted tree of N nodes . If there are multiple answers , return the answer that occurs last in the given 2D-array .
 Explanation : The given directed graph will be like this :
 Explanation : The given directed graph will be like this :
 The size of the input 2D-array will be between 3 and 1000 .
 Every integer represented in the 2D-array will be between 1 and N , where N is the size of the input array .
 You are given a string text of words that are placed among some number of spaces . Each word consists of one or more lowercase English letters and are separated by at least one space . It's guaranteed that text contains at least one word .
 Given a list of non-negative integers nums representing the amount of money of each house , return the maximum amount of money you can rob tonight without alerting the police .
 It is guaranteed that there are no consecutive repeating characters in the given string except for' ?' .
 Return the final string after all the conversions ( possibly zero ) have been made . If there is more than one solution , return any of them . It can be shown that an answer is always possible with the given constraints .
 Return a sequence of moves that makes our answer equal to target in the minimum number of moves . You may return any path that does so .
 Given an integer array destination and an integer k , return the k th lexicographically smallest instructions that will take Bob to destination .
 kthLargest.add ( 3 ) ; / / return 4
 kthLargest.add ( 5 ) ; / / return 5
 kthLargest.add ( 10 ) ; / / return 5
 kthLargest.add ( 9 ) ; / / return 8
 kthLargest.add ( 4 ) ; / / return 8
 Since the answer may be too large , return it modulo 10 ^ 9 + 7 .
 You are given a circular array nums of positive and negative integers . If a number k at an index is positive , then move forward k steps . Conversely , if it's negative (-k ) , move backward k steps . Since the array is circular , you may assume that the last element's next element is the first element , and the first element's previous element is the last element .
 We are given a 2-dimensional grid . " . " is an empty cell , " # " is a wall , " @ " is the starting point , ( " a " , " b " , ... ) are keys , and ( " A " , " B " , ... ) are locks .
 Return the lowest number of moves to acquire all keys . If it's impossible , return-1 .
 Stores the key and value , along with the given timestamp .
 kv.get ( " foo " , 1 ) ; / / output " bar "
 kv.get ( " foo " , 3 ) ; / / output " bar " since there is no value corresponding to foo at timestamp 3 and timestamp 2 , then the only value is at timestamp 1 ie " bar "
 kv.get ( " foo " , 4 ) ; / / output " bar2 "
 kv.get ( " foo " , 5 ) ; / / output " bar2 "
 Given a collection of integers that might contain duplicates , nums , return all possible subsets ( the power set ) .
 Return the least number of units of times that the CPU will take to finish all the given tasks .
 Please write a SQL query to output movies with an odd numbered ID and a description that is not' boring' . Order the result by rating .
 For the example above , the output should be :
 You are given an integer array heights representing the heights of buildings , some bricks , and some ladders .
 Return the furthest building index ( 0-indexed ) you can reach if you use the given ladders and bricks optimally .
 Then , the player went left , up , up , left to return home , picking up one more cherry .
 Given two anagrams A and B , return the smallest K for which A and B are K-similar .
 Return the number of ways we can draw k non-overlapping line segments . Since this number can be huge , return it modulo 10 9 + 7 .
 subrectangleQueries.getValue ( 0 , 2 ) ; / / return 1
 subrectangleQueries.getValue ( 0 , 2 ) ; / / return 5
 subrectangleQueries.getValue ( 3 , 1 ) ; / / return 5
 subrectangleQueries.getValue ( 3 , 1 ) ; / / return 10
 subrectangleQueries.getValue ( 0 , 2 ) ; / / return 5
 subrectangleQueries.getValue ( 0 , 0 ) ; / / return 1
 subrectangleQueries.getValue ( 0 , 0 ) ; / / return 100
 subrectangleQueries.getValue ( 2 , 2 ) ; / / return 100
 subrectangleQueries.getValue ( 2 , 2 ) ; / / return 20
 Given two integers n and k , return all possible combinations of k numbers out of 1 ... n .
 You may return the answer in any order .
 The input will be a list of strings , and the output needs to be the length of the longest uncommon subsequence . If the longest uncommon subsequence doesn't exist , return -1 .
 All the given strings' lengths will not exceed 10 .
 The length of the given list will be in the range of [ 2 , 50 ] .
 Given an integer n , return true if n is a perfect number , otherwise return false .
 Given a binary tree , return the level order traversal of its nodes' values . ( ie , from left to right , level by level ) .
 return its level order traversal as :
 string back ( int steps ) Move steps back in history . If you can only return x steps in the history and steps &gt; x , you will return only x steps . Return the current url after moving back in history at most steps .
 browserHistory.back ( 1 ) ; / / You are in "youtube.com " , move back to "facebook.com " return "facebook.com "
 browserHistory.back ( 1 ) ; / / You are in "facebook.com " , move back to "google.com " return "google.com "
 browserHistory.forward ( 1 ) ; / / You are in "google.com " , move forward to "facebook.com " return "facebook.com "
 browserHistory.back ( 2 ) ; / / You are in "linkedin.com " , move back two steps to "facebook.com " then to "google.com " . return "google.com "
 browserHistory.back ( 7 ) ; / / You are in "google.com " , you can move back only one step to "leetcode.com " . return "leetcode.com "
 Remove the minimum number of invalid parentheses in order to make the input string valid . Return all possible results .
 Note : The input string may contain letters other than the parentheses ( and ) .
 Given a matrix of M x N elements ( M rows , N columns ) , return all elements of the matrix in diagonal order as shown in the below image .
 The total number of elements of the given matrix will not exceed 10,000 .
 Given a VPS represented as string s , return the nesting depth of s .
 Return the latest 24-hour time in " HH : MM " format . If no valid time can be made , return an empty string .
 Say you have an array for which the i th element is the price of a given stock on day i .
 Given an input array nums , where nums [ i ] â‰  nums [ i +1 ] , find a peak element and return its index .
 The array may contain multiple peaks , in that case return the index to any one of the peaks is fine .
 Explanation : 3 is a peak element and your function should return the index number 2 .
 Explanation : Your function can return either index number 1 where the peak element is 2 ,
 void push ( int val ) Pushes the given positive integer val into the leftmost stack with size less than capacity .
 int popAtStack ( int index ) Returns the value at the top of the stack with the given index and removes it from that stack , and returns -1 if the stack with that given index is empty .
 Explanation : The first non-whitespace character is'-' , which is the minus sign . Then take as many numerical digits as possible , which gets 42 .
 Given a non-empty list of words , return the k most frequent elements .
 You are given two non-empty strings s1 and s2 ( each at most 100 characters long ) and two integers 0 â‰¤ n1 â‰¤ 10 6 and 1 â‰¤ n2 â‰¤ 10 6 . Now consider the strings S1 and S2 , where S1 = [ s1 , n1 ] and S2 = [ s2 , n2 ] . Find the maximum integer M such that [ S2 , M ] can be obtained from S1 .
 Your script should output the following valid phone numbers :
 Given a non-empty array of integers , return the k most frequent elements .
 You can return the answer in any order .
 The graph is given as follows : graph [ a ] is a list of all nodes b such that ab is an edge of the graph .
 Given a graph , and assuming both players play optimally , return 1 if the game is won by Mouse , 2 if the game is won by Cat , and 0 if the game is a draw .
 There are a total of n courses you have to take labelled from 0 to n-1 .
 Some courses may have prerequisites , for example , if prerequisites [ i ] = [ a i , b i ] this means you must take the course b i before the course a i .
 Given the total number of courses numCourses and a list of the prerequisite pairs , return the ordering of courses you should take to finish all courses .
 If there are many valid answers , return any of them . If it is impossible to finish all courses , return an empty array .
 Explanation : There are a total of 2 courses to take . To take course 1 you should have finished course 0 . So the correct course order is [ 0,1 ] .
 Explanation : There are a total of 4 courses to take . To take course 3 you should have finished both courses 1 and 2 . Both courses 1 and 2 should be taken after you finished course 0 .
 Since 2 has only one digit , return it .
 StreamChecker ( words ) : Constructor , init the data structure with the given words .
 query ( letter ) : returns true if and only if for some k &gt; = 1 , the last k characters queried ( in order from oldest to newest , including this letter just queried ) spell one of the words in the given list .
 streamChecker.query (' a' ) ; / / return false
 streamChecker.query (' b' ) ; / / return false
 streamChecker.query (' c' ) ; / / return false
 streamChecker.query ( 'd' ) ; / / return true , because' cd' is in the wordlist
 streamChecker.query (' e' ) ; / / return false
 streamChecker.query (' f' ) ; / / return true , because' f' is in the wordlist
 streamChecker.query (' g' ) ; / / return false
 streamChecker.query (' h' ) ; / / return false
 streamChecker.query (' i' ) ; / / return false
 streamChecker.query ( 'j' ) ; / / return false
 streamChecker.query (' k' ) ; / / return false
 streamChecker.query ( 'l' ) ; / / return true , because' kl' is in the wordlist
 Given an n-ary tree , return the postorder traversal of its nodes' values .
 Nary-Tree input serialization is represented in their level order traversal , each group of children is separated by the null value ( See examples ) .
 Given a rows * columns matrix mat of ones and zeros , return how many submatrices have all ones .
 You may return the answer in any order . In your answer , each value should occur at most once .
 Explanation : We have various ancestor-node differences , some of which are given below :
 For each such occurrence , add " third " to the answer , and return the answer .
 The input n is a positive integer represented by string , whose length will not exceed 18 .
 If there is a tie , return the smaller one as answer .
 You are given an array requests where requests [ i ] = [ from i , to i ] represents an employee's request to transfer from building from i to building to i .
 Each philosopher must alternately think and eat . However , a philosopher can only eat spaghetti when they have both left and right forks . Each fork can be held by only one philosopher and so a philosopher can use the fork only if it is not being used by another philosopher . After an individual philosopher finishes eating , they need to put down both forks so that the forks become available to others . A philosopher can take the fork on their right or the one on their left as they become available , but can not start eating before getting both forks .
 The output array describes the calls you made to the functions controlling the forks and the eat function , its format is :
 output [ i ] = [ a , b , c ] ( three integers )
 Given an integer n , return 1-n in lexicographical order .
 For example , given 13 , return : [ 1,10,11,12,13,2,3,4,5,6,7,8,9 ] .
 Please optimize your algorithm to use less time and space . The input size may be as large as 5,000,000 .
 Given an integer array arr and a target value target , return the integer value such that when we change all the integers larger than value in the given array to be equal to value , the sum of the array gets as close as possible ( in absolute difference ) to target .
 In case of a tie , return the minimum such integer .
 Some people will make friend requests . The list of their ages is given and ages [ i ] is the age of the ith person .
 Return a list of all possible strings we could create . You can return the output in any order .
 For example , your query should return the following for the above table :
 Given a string s containing just the characters' (' ,' )' ,' {' ,' }' ,' [' and' ]' , determine if the input string is valid .
 An input string is valid if :
 Given a singly linked list , return a random node's value from the linked list . Each node must have the same probability of being chosen .
 / / getRandom ( ) should return either 1 , 2 , or 3 randomly . Each element should have equal probability of returning .
 Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD , return the day number of the year .
 You are given a list logs , where logs [ i ] represents the i th log message formatted as a string " { function_id } :{ " start " | " end " } : { timestamp } " . For example , " 0 : start : 3 " means a function call with function ID 0 started at the beginning of timestamp 3 , and " 1 : end : 2 " means a function call with function ID 1 ended at the end of timestamp 2 . Note that a function can be called multiple times , possibly recursively .
 Do the above modifications to the input array in place , do not return anything from your function .
 Explanation : After calling your function , the input array is modified to : [ 1,0,0,2,3,0,0,4 ]
 Explanation : After calling your function , the input array is modified to : [ 1,2,3 ]
 Return an answer array ( of length seq.length ) that encodes such a choice of A and B : answer [ i ] = 0 if seq [ i ] is part of A , else answer [ i ] = 1 . Note that even though multiple answers may exist , you may return any of them .
 Given an m x n board of characters and a list of strings words , return all words on the board .
 Given two strings str1 and str2 , return the shortest string that has both str1 and str2 as subsequences . If multiple answers exist , you may return any of them .
 Since the answer may be too large , return it modulo 10 ^ 9 + 7 .
 Given a m * n matrix mat of ones ( representing soldiers ) and zeros ( representing civilians ) , return the indexes of the k weakest rows in the matrix ordered from the weakest to the strongest .
 If we erase the brick at ( 1 , 0 ) , the brick at ( 1 , 1 ) and ( 1 , 2 ) will drop . So we should return 2 .
 For example , given the following tree :
 You have n binary tree nodes numbered from 0 to n-1 where node i has two children leftChild [ i ] and rightChild [ i ] , return true if and only if all the given nodes form exactly one valid binary tree .
 Return True if its possible otherwise return False .
 Given an array nums of positive integers , return the longest possible length of an array prefix of nums , such that it is possible to remove exactly one element from this prefix so that every number that has appeared in it will have the same number of occurrences .
 The number of nodes in the given tree will be between 1 and 8500 .
 Given the array prices where prices [ i ] is the price of the ith item in a shop . There is a special discount for items in the shop , if you buy the ith item , then you will receive a discount equivalent to prices [ j ] where j is the minimum index such that j &gt; i and prices [ j ] &lt; = prices [ i ] , otherwise , you will not receive any discount at all .
 For item 0 with price [ 0 ] = 8 you will receive a discount equivalent to prices [ 1 ] = 4 , therefore , the final price you will pay is 8-4 = 4 .
 For item 1 with price [ 1 ] = 4 you will receive a discount equivalent to prices [ 3 ] = 2 , therefore , the final price you will pay is 4-2 = 2 .
 For item 2 with price [ 2 ] = 6 you will receive a discount equivalent to prices [ 3 ] = 2 , therefore , the final price you will pay is 6-2 = 4 .
 For items 3 and 4 you will not receive any discount at all .
 Explanation : In this case , for all items , you will not receive any discount at all .
 Also , there is a given gene " bank " , which records all the valid gene mutations . A gene must be in the bank to make it a valid gene string .
 Now , given 3 things-start , end , bank , your task is to determine what is the minimum number of mutations needed to mutate from " start " to " end " . If there is no such a mutation , return -1 .
 return : 1
 return : 2
 return : 3
 Validate if a given string can be interpreted as a decimal number .
 Of course , the context of these characters also matters in the input .
 Given a string representing a code snippet , you need to implement a tag validator to parse the code and return whether it is valid . A code snippet is valid if all the following rules hold :
 So TAG_CONTENT is valid , and then the code is valid . Thus return true .
 For simplicity , you could assume the input code ( including the any characters mentioned above ) only contain letters , digits ,' &lt;' ,' &gt;' ,' /' ,' !' ,' [' ,' ]' and '' .
 return its length 5 .
 Calling next ( ) will return the next smallest number in the BST .
 iterator.next ( ) ; / / return 3
 iterator.next ( ) ; / / return 7
 iterator.hasNext ( ) ; / / return true
 iterator.next ( ) ; / / return 9
 iterator.hasNext ( ) ; / / return true
 iterator.next ( ) ; / / return 15
 iterator.hasNext ( ) ; / / return true
 iterator.next ( ) ; / / return 20
 iterator.hasNext ( ) ; / / return false
 Given a binary tree and a sum , determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum .
 return true , as there exist a root-to-leaf path 5-&gt; 4-&gt; 11-&gt; 2 which sum is 22 .
 Since the answer may be large , return the answer modulo 10 ^ 9 + 7 .
 / / User 1's news feed should return a list with 1 tweet id-&gt; [ 5 ] .
 / / User 1's news feed should return a list with 2 tweet ids-&gt; [ 6 , 5 ] .
 / / User 1's news feed should return a list with 1 tweet id-&gt; [ 5 ] ,
 The edges of the undirected tree are given in the array edges , where edges [ i ] = [ from i , to i ] means that exists an edge connecting directly the vertices from i and to i .
 Explanation : The figure above shows the given graph . The frog starts at vertex 1 , jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2 . Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666 .
 Explanation : The figure above shows the given graph . The frog starts at vertex 1 , jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1 .
 You are given an integer array nums sorted in ascending order , and an integer target .
 If target is found in the array return its index , otherwise , return-1 .
 For each call to the method MyCalendar.book , return an integer K representing the largest integer such that there exists a K-booking in the calendar .
 Given an array of integers , return the maximum sum for a non-empty subarray ( contiguous elements ) with at most one element deletion . In other words , you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the sum of the remaining elements is maximum possible .
 Return the N-th magical number . Since the answer may be very large , return it modulo 10 ^ 9 + 7 .
 The given node will always be the first node with val = 1 . You must return the copy of the given node as a reference to the cloned graph .
 Explanation : Note that the input contains one empty list . The graph consists of only one node with val = 1 and it does not have any neighbors .
 The Graph is connected and all nodes can be visited starting from the given node .
 You are given coins of different denominations and a total amount of money amount . Write a function to compute the fewest number of coins that you need to make up that amount . If that amount of money can not be made up by any combination of the coins , return-1 .
 Given an integer n , return any array containing n unique integers such that they add up to 0 .
 Return a list of the words in words that match the given pattern .
 You may return the answer in any order .
 Given a list of daily temperatures T , return a list such that , for each day in the input , tells you how many days you would have to wait until a warmer temperature . If there is no future day for which this is possible , put 0 instead .
 For example , given the list of temperatures T = [ 73 , 74 , 75 , 71 , 69 , 72 , 76 , 73 ] , your output should be [ 1 , 1 , 4 , 2 , 1 , 1 , 0 , 0 ] .
 For some given string S , a query word is stretchy if it can be made to be equal to S by any number of applications of the following extension operation : choose a group consisting of characters c , and add some number of characters c to the group so that the size of the group is 3 or more .
 Given a list of query words , return the number of words that are stretchy .
 This question is the same as " Max Chunks to Make Sorted " except the integers of the given array are not necessarily distinct , the input array could be up to length 2000 , and the elements could be up to 10 ** 8 .
 Splitting into two or more chunks will not return the required result .
 On an infinite number line ( x-axis ) , we drop given squares in the order they are given .
 After the third drop of positions [ 1 ] = [ 6 , 1 ] : __ aaa __ aaa __ aaa _ aa _ aa ___ a -------------- The maximum height of any square is still 5 . Thus , we return an answer of [ 2 , 5 , 5 ] .
 Return the number of teams you can form given the conditions . ( soldiers can be part of multiple teams ) .
 Explanation : We can form three teams given the conditions . ( 2,3,4 ) , ( 5,4,1 ) , ( 5,3,1 ) .
 Explanation : We can't form any team given the conditions .
 Given a list of transactions , return a list of transactions that are possibly invalid . You may return the answer in any order .
 Given an integer array arr , return true if there are three consecutive odd numbers in the array . Otherwise , return false .
 At each step i ( assuming both the binary string and arr are 1-indexed ) from 1 to n , the bit at position arr [ i ] is set to 1 . You are given an integer m and you need to find the latest step at which there exists a group of ones of length m . A group of ones is a contiguous substring of 1s such that it can not be extended in either direction .
 Return the latest step at which there exists a group of ones of length exactly m . If no such group exists , return-1 .
 Given the coordinates of four points in 2D space , return whether the four points could construct a square .
 All the input integers are in the range [-10000 , 10000 ] .
 Given a string representing each senator's party belonging . The character' R' and 'D' represent the Radiant party and the Dire party respectively . Then if there are n senators , the size of the given string will be n .
 The round-based procedure starts from the first senator to the last senator in the given order . This procedure will last until the end of voting . All the senators who have lost their rights will be skipped during the procedure .
 Suppose every senator is smart enough and will play the best strategy for his own party , you need to predict which party will finally announce the victory and make the change in the Dota2 game . The output should be Radiant or Dire .
 The length of the given string will in the range [ 1 , 10,000 ] .
 Because the 3rd row is incomplete , we return 2 .
 Because the 4th row is incomplete , we return 3 .
 For example , given the dungeon below , the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT-&gt; DOWN-&gt; DOWN .
 Given a tree ( i.e. a connected , undirected graph that has no cycles ) consisting of n nodes numbered from 0 to n-1 and exactly n-1 edges . The root of the tree is the node 0 , and each node of the tree has a label which is a lower-case character given in the string labels ( i.e . The node with the number i has the label labels [ i ] ) .
 The edges array is given on the form edges [ i ] = [ a i , b i ] , which means there is an edge between nodes a i and b i in the tree .
 Given a list of trips , trip [ i ] = [ num_passengers , start_location , end_location ] contains information about the i-th trip : the number of passengers that must be picked up , and the locations to pick them up and drop them off . The locations are given as the number of kilometers due east from your vehicle's initial location .
 Return true if and only if it is possible to pick up and drop off all passengers for all the given trips .
 We then go to room 3 . Since we were able to go to every room , we return true .
 For example , given the above Logs table , 1 is the only number that appears consecutively for at least three times .
 Given the root node of a binary search tree ( BST ) and a value . You need to find the node in the BST that the node's value equals the given value . Return the subtree rooted with that node . If such node doesn't exist , you should return NULL .
 You should return this subtree :
 In the example above , if we want to search the value 5 , since there is no node with value 5 , we should return NULL .
 Note that an empty tree is represented by NULL , therefore you would see the expected output ( serialized tree format ) as [ ] , not null .
 Given a positive integer num , output its complement number . The complement strategy is to flip the bits of its binary representation .
 Explanation : The binary representation of 5 is 101 ( no leading zero bits ) , and its complement is 010 . So you need to output 2 .
 Explanation : The binary representation of 1 is 1 ( no leading zero bits ) , and its complement is 0 . So you need to output 0 .
 The given integer num is guaranteed to fit within the range of a 32-bit signed integer .
 Given two non-negative integers num1 and num2 represented as string , return the sum of num1 and num2 .
 Given two strings text1 and text2 , return the length of their longest common subsequence .
 If there is no common subsequence , return 0 .
 The input strings consist of lowercase English characters only .
 Given an undirected graph , return true if and only if it is bipartite .
 The graph is given in the following form : graph [ i ] is a list of indexes j for which the edge between nodes i and j exists . Each node is an integer between 0 and graph.length-1 . There are no self edges or parallel edges : graph [ i ] does not contain i , and it doesn't contain any element twice .
 Write a program to check whether a given number is an ugly number .
 Since the answer may be large , return the answer modulo 10 ^ 9 + 7 .
 Given the string s , return the size of the longest substring containing each vowel an even number of times . That is ,' a' ,' e' ,' i' ,' o' , and' u' must appear an even number of times .
 Explanation : In this case , the given string " bcbcbc " is the longest because all vowels : a , e , i , o and u appear zero times .
 The row number m should be equal to the height of the given binary tree .
 Given the head of a linked list , return the list after sorting it in ascending order .
 Given an expression such as expression = " e + 8-a + 5 " and an evaluation map such as { " e " : 1 } ( given in terms of evalvars = [ " e " ] and evalints = [ 1 ] ) , return a list of tokens representing the simplified expression , such as [ "-1 * a " , " 14 " ]
 The format of the output is as follows :
 Terms ( including constant terms ) with coefficient 0 are not included . For example , an expression of " 0 " has an output of [ ] .
 You are given trust , an array of pairs trust [ i ] = [ a , b ] representing that the person labelled a trusts the person labelled b .
 If the town judge exists and can be identified , return the label of the town judge . Otherwise , return-1 .
 Return the minimum number of taps that should be open to water the whole garden , If the garden can not be watered return-1 .
 Given two strings s1 and s2 , write a function to return true if s2 contains the permutation of s1 . In other words , one of the first string's permutations is the substring of the second string .
 The input strings only contain lower case letters .
 The length of both given strings is in range [ 1 , 10,000 ] .
 Given an integer n , return a list of all simplified fractions between 0 and 1 ( exclusive ) such that the denominator is less-than-or-equal-to n . The fractions can be in any order .
 Compute and return the square root of x , where x is guaranteed to be a non-negative integer .
 Since the return type is an integer , the decimal digits are truncated and only the integer part of the result is returned .
 Over all possible rotations , return the rotation index K that corresponds to the highest score we could receive . If there are multiple answers , return the smallest such index K.
 You want to distribute the candies equally between a sister and a brother so that each of them gets n / 2 candies ( n is even ) . The sister loves to collect different types of candies , so you want to give her the maximum number of different types of candies .
 Return the maximum number of different types of candies you can give to the sister .
 Return true if and only if the given tree is univalued .
 The number of nodes in the given tree will be in the range [ 1 , 100 ] .
 Given an array consists of non-negative integers , your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle .
 The length of the given array won't exceed 1000 .
 The integers in the given array are in the range of [ 0 , 1000 ] .
 Since the answer may be too large , return it modulo 10 ^ 9 + 7 .
 Given an encoded string , return its decoded string .
 You may assume that the input string is always valid ; No extra white spaces , square brackets are well-formed , etc.
 Furthermore , you may assume that the original data does not contain any digits and that digits are only for those repeat numbers , k . For example , there won't be input like 3a or 2 [ 4 ] .
 We are given two arrays A and B of words . Each word is a string of lowercase letters .
 Return a list of all universal words in A . You can return the words in any order .
 You need to return a string representing their multiplication . Note i 2 = -1 according to the definition .
 The input strings will not have extra blank .
 The input strings will be given in the form of a + bi , where the integer a and b will both belong to the range of [-100 , 100 ] . And the output should be also in this form .
 Rearrange the barcodes so that no two adjacent barcodes are equal . You may return any answer , and it is guaranteed an answer exists .
 Write a SQL query to find employees who have the highest salary in each of the departments . For the above tables , your SQL query should return the following rows ( order of rows does not matter ) .
 In a given integer array A , we must move every element of A to either list B or list C. ( B and C initially start empty . )
 Given two sequences pushed and popped with distinct values , return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack .
 Given two strings A and B of lowercase letters , return true if you can swap two letters in A so the result is equal to B , otherwise , return false .
 You are given the number of rows n_rows and number of columns n_cols of a 2D binary matrix where all values are initially 0 . Write a function flip which chooses a 0 value uniformly at random , changes it to 1 , and then returns the position [ row.id , col.id ] of that value . Also , write a function reset which sets all values back to 0 . Try to minimize the number of calls to system's Math.random ( ) and optimize the time and space complexity .
 The input is two lists : the subroutines called and their arguments . Solution's constructor has two arguments , n_rows and n_cols . flip and reset have no arguments . Arguments are always wrapped with a list , even if there aren't any .
 You are given a list of deadends dead ends , meaning if the lock displays any of these codes , the wheels of the lock will stop turning and you will be unable to open it .
 Given a target representing the value of the wheels that will unlock the lock , return the minimum total number of turns required to open the lock , or -1 if it is impossible .
 Given a rows x cols matrix mat , where mat [ i ] [ j ] is either 0 or 1 , return the number of special positions in mat .
 On this problem given a string s we need to return the sum of countUniqueChars ( t ) where t is a substring of s . Notice that some substrings can be repeated so on this case you have to count the repeated ones too .
 Since the answer can be very large , return the answer modulo 10 ^ 9 + 7 .
 Return the reformatted string or return an empty string if it is impossible to reformat the string .
 Given two arrays of integers with equal lengths , return the maximum value of :
 Each customer will only buy one lemonade and pay with either a $ 5 , $ 10 , or $ 20 bill . You must provide the correct change to each customer , so that the net transaction is that the customer pays $ 5 .
 Return true if and only if you can provide every customer with correct change .
 From the fourth customer , we collect a $ 10 bill and give back a $ 5 .
 From the fifth customer , we give a $ 10 bill and a $ 5 bill .
 Since all customers got correct change , we output true .
 For the next two customers in order , we collect a $ 10 bill and give back a $ 5 bill .
 For the last customer , we can't give change of $ 15 back because we only have two $ 10 bills .
 Now given N , how many beautiful arrangements can you construct ?
 Follow-up : Can you implement the stack such that each operation is amortized O ( 1 ) time complexity ? In other words , performing n operations will take overall O ( n ) time even if one of those operations may take longer .
 myStack.top ( ) ; / / return 2
 myStack.pop ( ) ; / / return 2
 myStack.empty ( ) ; / / return False
 Given a string S and a character C , return an array of integers representing the shortest distance from the character C in the string .
 If a certain line of code is empty after removing comments , you must not output that line : each string in the answer list will be non-empty .
 After removing the comments from the source code , return the source code in the same format .
 Given a binary string S ( a string consisting only of' 0' and' 1's ) and a positive integer N , return true if and only if for every integer X from 1 to N , the binary representation of X is a substring of S.
 A string S of lowercase letters is given . Then , we may make any number of moves .
 If there are multiple solutions , return any subset is fine .
 Given a non negative integer number num . For every numbers i in the range 0 â‰¤ i â‰¤ num calculate the number of 1's in their binary representation and return them as an array .
 Return the minimum number of days you need to wait to be able to make m bouquets from the garden . If it is impossible to make m bouquets return-1 .
 Explanation : We need 3 bouquets each has 2 flowers , that means we need 6 flowers . We only have 5 flowers so it is impossible to get the needed bouquets and we return -1 .
 Above is a histogram where width of each bar is 1 , given height = [ 2,1,5,6,2,3 ] .
 Given a linked list , return the node where the cycle begins . If there is no cycle , return null .
 Given a binary tree , find the lowest common ancestor ( LCA ) of two given nodes in the tree .
 The output represents the serialized format of a Quad-Tree using level order traversal , where null signifies a path terminator where no node exists below .
 Given a root node reference of a BST and a key , delete the node with the given key in the BST . Return the root node reference ( possibly updated ) of the BST .
 Explanation : s contains 4 prefix excluding itself ( " l " , " le " , " lev " , " leve " ) , and suffix ( " l " , " el " , " vel " , " evel " ) . The largest prefix which is also suffix is given by " l " .
 Given two strings str1 and str2 , return the largest string x such that x divides both str1 and str2 .
 Given an array of integers nums and an integer limit , return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit .
 The i-th package on the conveyor belt has a weight of weights [ i ] . Each day , we load the ship with packages on the conveyor belt ( in the order given by weights ) . We may not load more weight than the maximum weight capacity of the ship .
 Note that the cargo must be shipped in the order given , so using a ship of capacity 14 and splitting the packages into parts like ( 2 , 3 , 4 , 5 ) , ( 1 , 6 , 7 ) , ( 8 ) , ( 9 ) , ( 10 ) is not allowed .
 An undirected , connected tree with N nodes labelled 0...N-1 and N-1 edges are given .
 Here is a diagram of the given tree :
 Explanation : The two lists do not intersect , so return null .
 If the two linked lists have no intersection at all , return null .
 minStack.getMin ( ) ; / / return -3
 minStack.top ( ) ; / / return 0
 minStack.getMin ( ) ; / / return -2
 We are given an array A of N lowercase letter strings , all of the same length .
 Given a string s consists of upper / lower-case alphabets and empty space characters '' , return the length of last word ( last word means the last appearing word if we loop from left to right ) in the string .
 If the last word does not exist , return 0 .
 For convenience , the full table for the 26 letters of the English alphabet is given below :
 Now , given a list of words , each word can be written as a concatenation of the Morse code of each letter . For example , " cab " can be written as "-.-. . -- ... " , ( which is the concatenation "-.-. " + " .-" + "-... " ) . We'll call such a concatenation , the transformation of a word .
 Given an array nums and a value val , remove all instances of that value in-place and return the new length .
 Do not allocate extra space for another array , you must do this by modifying the input array in-place with O ( 1 ) extra memory .
 Note that the input array is passed in by reference , which means a modification to the input array will be known to the caller as well .
 Explanation : Your function should return length = 2 , with the first two elements of nums being 2 .
 It doesn't matter what you leave beyond the returned length . For example if you return 2 with nums = [ 2,2,3,3 ] or nums = [ 2,3,0,0 ] , your answer will be accepted .
 Explanation : Your function should return length = 5 , with the first five elements of nums containing 0 , 1 , 3 , 0 , and 4 . Note that the order of those five elements can be arbitrary . It doesn't matter what values are set beyond the returned length .
 Given target = 5 , return true .
 Given target = 20 , return false .
 Since the answer may be too large , return it modulo 10 ^ 9 + 7 .
 Explanation : There is only one way to choose hats given the conditions .
 Given a list of words ( without duplicates ) , please write a program that returns all concatenated words in the given list of words .
 A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array .
 The number of elements of the given array will not exceed 10,000
 The length sum of elements in the given array will not exceed 600,000 .
 All the input string will only include lower case letters .
 Now given all the cities and flights , together with starting city src and the destination dst , your task is to find the cheapest price from src to dst with up to k stops . If there is no such route , output-1 .
 You are given a string containing only 4 kinds of characters' Q' ,' W' ,' E' and' R' .
 Given a collection of numbers , nums , that might contain duplicates , return all possible unique permutations in any order .
 ParkingSystem ( int big , int medium , int small ) Initializes object of the ParkingSystem class . The number of slots for each parking space are given as part of the constructor .
 bool addCar ( int carType ) Checks whether there is a parking space of carType for the car that wants to get into the parking lot . carType can be of three kinds : big , medium , or small , which are represented by 1 , 2 , and 3 respectively . A car can only park in a parking space of its carType . If there is no space available , return false , else park the car in that size space and return true .
 parkingSystem.addCar ( 1 ) ; / / return true because there is 1 available slot for a big car
 parkingSystem.addCar ( 2 ) ; / / return true because there is 1 available slot for a medium car
 parkingSystem.addCar ( 3 ) ; / / return false because there is no available slot for a small car
 parkingSystem.addCar ( 1 ) ; / / return false because there is no available slot for a big car . It is already occupied .
 Given two numbers arr1 and arr2 in base-2 , return the result of adding them together .
 Each number is given in array format : as an array of 0s and 1s , from most significant bit to least significant bit . For example , arr = [ 1,1,0,1 ] represents the number (-2 ) ^ 3 + (-2 ) ^ 2 + (-2 ) ^ 0 = -3 . A number arr in array , format is also guaranteed to have no leading zeros : either arr == [ 0 ] or arr [ 0 ] == 1 .
 Explanation : arr1 represents 11 , arr2 represents 5 , the output represents 16 .
 Now , given string arrays queries and words , return an integer array answer , where each answer [ i ] is the number of words such that f ( queries [ i ] ) &lt; f ( W ) , where W is a word in words .
 Given a circular array ( the next element of the last element is the first element of the array ) , print the Next Greater Number for every element . The Next Greater Number of a number x is the first greater number to its traversing-order next in the array , which means you could search circularly to find its next greater number . If it doesn't exist , output -1 for this number .
 The length of given array won't exceed 10000 .
 In a string composed of 'L' ,' R' , and' X' characters , like " RXXLRXRXL " , a move consists of either replacing one occurrence of " XL " with " LX " , or replacing one occurrence of " RX " with " XR " . Given the starting string start and the ending string end , return True if and only if there exists a sequence of moves to transform one string to the other .
 Given a string s , return the maximum number of ocurrences of any substring under the following rules :
 f ( string prefix , string suffix ) Returns the index of the word in the dictionary which has the prefix prefix and the suffix suffix . If there is more than one valid index , return the largest of them . If there is no such word in the dictionary , return-1 .
 wordFilter.f ( " a " , " e " ) ; / / return 0 , because the word at index 0 has prefix = " a " and suffix =' e " .
 Return a list of all MHTs' root labels . You can return the answer in any order .
 The given input is guaranteed to be a tree and there will be no repeated edges .
 Given a string of numbers and operators , return all possible results from computing all the different possible ways to group numbers and operators . The valid operators are + ,-and * .
 customStack.pop ( ) ; / / return 2 -- &gt; Return top of the stack 2 , stack becomes [ 1 ]
 customStack.pop ( ) ; / / return 103 -- &gt; Return top of the stack 103 , stack becomes [ 201 , 202 ]
 customStack.pop ( ) ; / / return 202 -- &gt; Return top of the stack 102 , stack becomes [ 201 ]
 customStack.pop ( ) ; / / return 201 -- &gt; Return top of the stack 101 , stack becomes [ ]
 customStack.pop ( ) ; / / return -1 -- &gt; Stack is empty return -1 .
 Given a set of distinct integers , nums , return all possible subsets ( the power set ) .
 return 13 .
 The given number is in the range [ 0 , 10 8 ]
 Your task is to calculate a b mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array .
 You are given a list of strings keyName and keyTime where [ keyName [ i ] , keyTime [ i ] ] corresponds to a person's name and the time when their key-card was used in a single day .
 Access times are given in the 24-hour time format " HH : MM " , such as " 23:51 " and " 09:49 " .
 Return the minimum sum of the lengths of the two required sub-arrays , or return-1 if you can not find such two sub-arrays .
 Hence , player 1 will never be the winner and you need to return False .
 Finally , player 1 has more score ( 234 ) than player 2 ( 12 ) , so you need to return True representing player1 can win .
 Any scores in the given array are non-negative integers and will not exceed 10,000,000 .
 Return the root node of a binary search tree that matches the given preorder traversal .
 It's guaranteed that for the given test cases there is always possible to find a binary search tree with the given requirements .
 Your script should output the tenth line , which is :
 1 . If the file contains less than 10 lines , what should you output ?
 But for multiples of three it should output â€œ Fizz â€ instead of the number and for the multiples of five output â€œ Buzz â€ . For numbers which are multiples of both three and five output â€œ FizzBuzz â€ .
 A sentence S is given , composed of words separated by spaces . Each word consists of lowercase and uppercase letters only .
 cashier.getBill ( [ 1,2 ] , [ 1,2 ] ) ; / / return 500.0 , bill = 1 * 100 + 2 * 200 = 500 .
 cashier.getBill ( [ 3,7 ] , [ 10,10 ] ) ; / / return 4000.0
 cashier.getBill ( [ 1,2,3,4,5,6,7 ] , [ 1,1,1,1,1,1,1 ] ) ; / / return 800.0 , The bill was 1600.0 but as this is the third customer , he has a discount of 50 % which means his bill is only 1600-1600 * ( 50 / 100 ) = 800 .
 cashier.getBill ( [ 4 ] , [ 10 ] ) ; / / return 4000.0
 cashier.getBill ( [ 7,3 ] , [ 10,10 ] ) ; / / return 4000.0
 cashier.getBill ( [ 7,5,3,1,6,4,2 ] , [ 10,10,10,9,9,9,7 ] ) ; / / return 7350.0 , Bill was 14700.0 but as the system counted three more customers , he will have a 50 % discount and the bill becomes 7350.0
 cashier.getBill ( [ 2,3,5 ] , [ 5,3,2 ] ) ; / / return 2500.0
 Given two sorted arrays nums1 and nums2 of size m and n respectively , return the median of the two sorted arrays .
 You are given several projects . For each project i , it has a pure profit P i and a minimum capital of C i is needed to start the corresponding project . Initially , you have W capital . When you finish a project , you will obtain its pure profit and the profit will be added to your total capital .
 To sum up , pick a list of at most k distinct projects from given projects to maximize your final capital , and output your final maximized capital .
 After finishing it you will obtain profit 1 and your capital becomes 1 .
 Therefore , output the final maximized capital , which is 0 + 1 + 3 = 4 .
 You may assume all numbers in the input are non-negative integers .
 Given a matrix and a target , return the number of non-empty submatrices that sum to target .
 Given an integer n , return the number of distinct solutions to the n-queens puzzle .
 Given an array of integers rollMax and an integer n , return the number of distinct sequences that can be obtained with exact n rolls .
 Two sequences are considered different if at least one element differs from each other . Since the answer may be too large , return it modulo 10 ^ 9 + 7 .
 A Tic-Tac-Toe board is given as a string array board . Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game .
 Players take turns placing characters into empty squares ( " " ) .
 Explanation : Players take turns making moves .
 Given an m x n 2d grid map of' 1' s ( land ) and' 0' s ( water ) , return the number of islands .
 You're given a matrix represented by a two-dimensional array , and two positive integers r and c representing the row number and column number of the wanted reshaped matrix , respectively .
 If the' reshape' operation with given parameters is possible and legal , output the new reshaped matrix ; Otherwise , output the original matrix .
 Explanation : There is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix . So output the original matrix .
 The height and width of the given matrix is in range [ 1 , 100 ] .
 The given r and c are all positive .
 Return true if there exists a pattern of length m that is repeated k or more times , otherwise return false .
 We are to write the letters of a given string S , from left to right into lines . Each line has maximum width 100 units , and if writing a letter would cause the width of the line to exceed 100 units , it is written on the next line . We are given an array widths , an array where widths [ 0 ] is the width of' a' , widths [ 1 ] is the width of' b' , ... , and widths [ 25 ] is the width of' z' .
 You are given a rows x cols matrix grid . Initially , you are located at the top-left corner ( 0 , 0 ) , and in each step , you can only move right or down in the matrix .
 Return the maximum non-negative product modulo 10 9 + 7 . If the maximum product is negative return-1 .
 Explanation : It's not possible to get non-negative product in the path from ( 0 , 0 ) to ( 2 , 2 ) , so return -1 .
 Given an array A of integers , return the length of the longest arithmetic subsequence in A .
 Given a non-empty array of integers , return the third maximum number in this array . If it does not exist , return the maximum number . The time complexity must be in O ( n ) .
 You are given two arrays rowSum and colSum of non-negative integers where rowSum [ i ] is the sum of the elements in the i th row and colSum [ j ] is the sum of the elements of the j th column of a 2D matrix . In other words , you do not know the elements of the matrix , but you do know the sums of each row and column .
 Given a binary tree root , the task is to return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree ( BST ) .
 The given binary tree will have between 1 and 40000 nodes .
 Given a linked list , reverse the nodes of a linked list k at a time and return its modified list .
 If it can not be done , return-1 .
 The first figure represents the dominoes as given by A and B : before we do any rotations .
 Note again that at each step of the above process , the order of the books we place is the same order as the given sequence of books . For example , if we have an ordered list of 5 books , we might place the first and second book onto the first shelf , the third book on the second shelf , and the fourth and fifth book on the last shelf .
 You are given an integer n . An array nums of length n + 1 is generated in the following way :
 Explanation : According to the given rules :
 Explanation : According to the given rules , the maximum between nums [ 0 ] , nums [ 1 ] , and nums [ 2 ] is 1 .
 Explanation : According to the given rules , the maximum between nums [ 0 ] , nums [ 1 ] , nums [ 2 ] , and nums [ 3 ] is 2 .
 After merging the accounts , return the accounts in the following format : the first element of each account is the name , and the rest of the elements are emails in sorted order . The accounts themselves can be returned in any order .
 We could return these lists in any order , for example the answer [ [' Mary' , 'mary@mail.com' ] , [' John' , 'johnnybravo@mail.com' ] ,
 Given a lower and upper number bound , output a list of every possible self dividing number , including the bounds if possible .
 The boundaries of each input argument are 1 &lt; = left &lt; = right &lt; = 10000 .
 Return the longest possible length of a word chain with words chosen from the given list of words .
 In a country popular for train travel , you have planned some train travelling one year in advance . The days of the year that you will travel is given as an array days . Each day is an integer from 1 to 365 .
 Return the minimum number of dollars you need to travel every day in the given list of days .
 For every ( contiguous ) subarray B = [ A [ i ] , A [ i +1 ] , ... , A [ j ] ] ( with i &lt; = j ) , we take the bitwise OR of all the elements in B , obtaining a result A [ i ] | A [ i +1 ] | ... | A [ j ] .
 You are given two strings a and b of the same length . Choose an index and split both strings at the same index , splitting a into two strings : a prefix and a suffix where a = a prefix + a suffix , and splitting b into two strings : b prefix and b suffix where b = b prefix + b suffix . Check if a prefix + b suffix or b prefix + a suffix forms a palindrome .
 Return true if it is possible to form a palindrome string , otherwise return false .
 When we serve some soup , we give it to someone and we no longer have it . Each turn , we will choose from the four operations with equal probability 0.25 . If the remaining volume of soup is not enough to complete the operation , we will serve as much as we can . We stop once we no longer have some quantity of both types of soup .
 Return the number of positive integers that can be generated that are less than or equal to a given integer n .
 We are given a matrix with R rows and C columns has cells with integer coordinates ( r , c ) , where 0 &lt; = r &lt; R and 0 &lt; = c &lt; C .
 Additionally , we are given a cell in that matrix with coordinates ( r0 , c0 ) .
 Return the coordinates of all cells in the matrix , sorted by their distance from ( r0 , c0 ) from smallest distance to largest distance . Here , the distance between two cells ( r1 , c1 ) and ( r2 , c2 ) is the Manhattan distance , | r1-r2 | + | c1-c2 | . ( You may return the answer in any order that satisfies this condition . )
 Return the minimum number of steps to walk from the upper left corner ( 0 , 0 ) to the lower right corner ( m-1 , n-1 ) given that you can eliminate at most k obstacles . If it is not possible to find such walk return -1 .
 Given two integers representing the numerator and denominator of a fraction , return the fraction in string format .
 If multiple answers are possible , return any of them .
 It is guaranteed that the length of the answer string is less than 10 4 for all the given inputs .
 If there isn't any rectangle , return 0 .
 You are given the each item's price , a set of special offers , and the number we need to buy for each item .
 The job is to output the lowest price you have to pay for exactly certain items as given , where you could make optimal use of the special offers .
 Given a string s , return the last substring of s in lexicographical order .
 Given an array of distinct integers candidates and a target integer target , return a list of all unique combinations of candidates where the chosen numbers sum to target . You may return the combinations in any order .
 It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input .
 You may return any answer array that satisfies this condition .
 Return [ total_jumbo , total_small ] so that the number of remaining tomatoSlices equal to 0 and the number of remaining cheeseSlices equal to 0 . If it is not possible to make the remaining tomatoSlices and cheeseSlices equal to 0 return [ ] .
 You are given two jugs with capacities x and y litres . There is an infinite amount of water supply available . You need to determine whether it is possible to measure exactly z litres using these two jugs .
 There are 3n piles of coins of varying size , you and your friends will take piles of coins as follows :
 The edges of the undirected tree are given in the array edges , where edges [ i ] = [ from i , to i ] means that exists an edge connecting the vertices from i and to i . Additionally , there is a boolean array hasApple , where hasApple [ i ] = true means that vertex i has an apple , otherwise , it does not have any apple .
 Explanation : The figure above represents the given tree where red vertices have an apple . One optimal path to collect all apples is shown by the green arrows .
 Explanation : The figure above represents the given tree where red vertices have an apple . One optimal path to collect all apples is shown by the green arrows .
 Given an array nums of integers , return how many of them contain an even number of digits .
 findElements.find ( 1 ) ; / / return False
 findElements.find ( 2 ) ; / / return True
 findElements.find ( 1 ) ; / / return True
 findElements.find ( 3 ) ; / / return True
 findElements.find ( 5 ) ; / / return False
 findElements.find ( 2 ) ; / / return True
 findElements.find ( 3 ) ; / / return False
 findElements.find ( 4 ) ; / / return False
 findElements.find ( 5 ) ; / / return True
 Given n , return the value of T n .
 Return the minimum cost of painting all the remaining houses in such a way that there are exactly target neighborhoods , if not possible return-1 .
 Given an integer rowIndex , return the rowIndex th row of the Pascal's triangle .
 Given an integer n , return the number of trailing zeroes in n ! .
 Given a positive integer N , return the number of positive integers less than or equal to N that have at least 1 repeated digit .
 Given a string representing an expression of fraction addition and subtraction , you need to return the calculation result in string format . The final result should be irreducible fraction . If your final result is an integer , say 2 , you need to change it to the format of fraction that has denominator 1 . So in this case , 2 should be converted to 2/1 .
 The input string only contains' 0' to' 9' ,' /' ,' +' and'-' . So does the output .
 Each fraction ( input and output ) has format Â± numerator / denominator . If the first input fraction or the output is positive , then' +' will be omitted .
 The input only contains valid irreducible fractions , where the numerator and denominator of each fraction will always be in the range [ 1,10 ] . If the denominator is 1 , it means this fraction is actually an integer in a fraction format defined above .
 The number of given fractions will be in the range [ 1,10 ] .
 Consider a list of all factors of n sorted in ascending order , return the kth factor in this list or return-1 if n has less than k factors .
 Explanation : Factors list is [ 1 , 2 , 4 ] , there is only 3 factors . We should return -1 .
 Merge two sorted linked lists and return it as a new sorted list . The new list should be made by splicing together the nodes of the first two lists .
 Given an integer , return its base 7 string representation .
 The input will be in range of [-1e7 , 1e7 ] .
 You are given the array paths , where paths [ i ] = [ cityA i , cityB i ] means there exists a direct path going from cityA i to cityB i . Return the destination city , that is , the city without any path outgoing to another city .
 There are some spherical balloons spread in two-dimensional space . For each balloon , provided input is the start and end coordinates of the horizontal diameter . Since it's horizontal , y-coordinates don't matter , and hence the x-coordinates of start and end of the diameter suffice . The start is always smaller than the end .
 Given an array points where points [ i ] = [ x start , x end ] , return the minimum number of arrows that must be shot to burst all balloons .
 Given an integer array nums , find three numbers whose product is maximum and return the maximum product .
 Given a matrix A , return the transpose of A .
 Given a List of words , return the words that can be typed using letters of alphabet on only one row's of American keyboard like the image below .
 You may assume the input string will only contain letters of alphabet .
 The above output corresponds to the 5 unique BST's shown below :
 Return true if and only if it is possible to assign integers to variable names so as to satisfy all the given equations .
 Now , we send a signal from a certain node K . How long will it take for all nodes to receive the signal ? If it is impossible , return-1 .
 You are given two sorted arrays of distinct integers nums1 and nums2 .
 Return the maximum score you can obtain of all possible valid paths .
 Since the answer may be too large , return it modulo 10 ^ 9 + 7 .
 At the end , return the modified image .
 The given starting pixel will satisfy 0 &lt; = sr &lt; image.length and 0 &lt; = sc &lt; image [ 0 ] . length .
 Given the root of a binary tree , return the postorder traversal of its nodes' values .
 What is the minimum number of moves to transform the board into a " chessboard "-a board where no 0 s and no 1 s are 4-directionally adjacent ? If the task is impossible , return -1 .
 Write a function that takes a string as input and reverse only the vowels of a string .
 Given an array nums , there is a sliding window of size k which is moving from the very left of the array to the very right . You can only see the k numbers in the window . Each time the sliding window moves right by one position . Your job is to output the median array for each window in the original array .
 Therefore , return the median sliding window as [ 1,-1,-1,3,5,6 ] .
 You may assume k is always valid , ie : k is always smaller than input array's size for non-empty array .
 Given an array A of integers , return the length of the longest mountain .
 You are given an array of n integers , nums , and two arrays of m integers each , l and r , representing the m range queries , where the i th query is the range [ l [ i ] , r [ i ] ] . All the arrays are 0-indexed .
 Return true if there is a 132 pattern in nums , otherwise , return false .
 Explanation : There are three threads being fired asynchronously . The input [ 1,2,3 ] means thread A calls first ( ) , thread B calls second ( ) , and thread C calls third ( ) . " firstsecondthird " is the correct output .
 Explanation : The input [ 1,3,2 ] means thread A calls first ( ) , thread B calls third ( ) , and thread C calls second ( ) . " firstsecondthird " is the correct output .
 We do not know how the threads will be scheduled in the operating system , even though the numbers in the input seems to imply the ordering . The input format you see is mainly to ensure our tests' comprehensiveness .
 A zero-indexed array A consisting of N numbers is given . A slice of that array is any pair of integers ( P , Q ) such that 0 &lt; = P &lt; Q &lt; N.
 The function should return the number of arithmetic slices in the array A.
 return : 3 , for 3 arithmetic slices in A : [ 1 , 2 , 3 ] , [ 2 , 3 , 4 ] and [ 1 , 2 , 3 , 4 ] itself .
 Given an integer number n , return the difference between the product of its digits and the sum of its digits .
 If version1 &lt; version2 , return-1 .
 If version1 &gt; version2 , return 1 .
 Otherwise , return 0 .
 All the given revisions in version1 and version2 can be stored in a 32-bit integer .
 Given two integer arrays arr1 and arr2 , and the integer d , return the distance value between the two arrays .
 For example , given the above Employee table , the query should return 200 as the second highest salary . If there is no second highest salary , then the query should return null .
 Given a m x n matrix mat and an integer threshold . Return the maximum side-length of a square with a sum less than or equal to threshold or return 0 if there is no such square .
 You're given the startTime , endTime and profit arrays , you need to output the maximum profit you can take such that there are no 2 jobs in the subset with overlapping time range .
 Alex and Lee take turns , with Alex starting first . Initially , M = 1 .
 On each player's turn , that player can take all the stones in the first X remaining piles , where 1 &lt; = X &lt; = 2M . Then , we set M = max ( M , X ) .
 Assuming Alex and Lee play optimally , return the maximum number of stones Alex can get .
 Explanation : If Alex takes one pile at the beginning , Lee takes two piles , then Alex takes 2 piles again . Alex can get 2 + 4 + 4 = 10 piles in total . If Alex takes two piles at the beginning , then Lee can take all three piles left . In this case , Alex get 2 + 7 = 9 piles in total . So we return 10 since it's larger .
 Given an integer array representing the number of dresses in each washing machine from left to right on the line , you should find the minimum number of moves to make all the washing machines have the same number of dresses . If it is not possible to do it , return -1 .
 You are given two strings s and t of the same length . You want to change s to t . Changing the i-th character of s to i-th character of t costs | s [ i ]-t [ i ] | that is , the absolute difference between the ASCII values of the characters .
 You are also given an integer maxCost .
 If there is no substring from s that can be changed to its corresponding substring from t , return 0 .
 Given a m * n matrix of distinct numbers , return all lucky numbers in the matrix in any order .
 CBTInserter ( TreeNode root ) initializes the data structure on a given tree with head node root ;
 CBTInserter.get_root ( ) will return the head node of the tree .
 The initial given tree is complete and contains between 1 and 1000 nodes .
 Every value of a given or inserted node is between 0 and 5000 .
 You are given an array points , an integer angle , and your location , where location = [ pos x , pos y ] and points [ i ] = [ x i , y i ] both denote integral coordinates on the X-Y plane .
 Initially , you are facing directly east from your position . You can not move from your position , but you can rotate . In other words , pos x and pos y can not be changed . Your field of view in degrees is represented by angle , determining how wide you can see from any given view direction . Let d be the amount in degrees that you rotate counterclockwise . Then , your field of view is the inclusive range of angles [ d-angle / 2 , d + angle / 2 ] .
 GetMaxKey ( )-Returns one of the keys with maximal value . If no element exists , return an empty string " " .
 GetMinKey ( )-Returns one of the keys with minimal value . If no element exists , return an empty string " " .
 You are given a string representing an attendance record for a student . The record only contains the following three characters :
 You need to return whether the student could be rewarded according to his attendance record .
 Return the minimum difficulty of a job schedule . If you can not find a schedule for the jobs return-1 .
 Explanation : If you finish a job per day you will still have a free day . you can not find a schedule for the given jobs .
 Explanation : The array contains less than 2 elements , therefore return 0 .
 A good string has size n , it is alphabetically greater than or equal to s1 , it is alphabetically smaller than or equal to s2 , and it does not contain the string evil as a substring . Since the answer can be a huge number , return this modulo 10 ^ 9 + 7 .
 Given a particular n , return the minimum amount of money you need to guarantee a win regardless of what number I pick .
 Given a string S , return the " reversed " string where all characters that are not a letter stay in the same place , and all letters reverse their positions .
 For the above tables , your SQL query should return the following rows with the cancellation rate being rounded to two decimal places .
 You may assume that the input format is always valid , for example it could never contain two consecutive commas such as " 1 , ,3 " .
 You are given a map of a server center , represented as a m * n integer matrix grid , where 1 means that on that cell there is a server and 0 means that it is no server . Two servers are said to communicate if they are on the same row or on the same column .
 bool erase ( int num ) : Remove a value in the Skiplist . If num does not exist in the Skiplist , do nothing and return false . If there exists multiple num values , removing any one of them is fine .
 skiplist.search ( 0 ) ; / / return false .
 skiplist.search ( 1 ) ; / / return true .
 skiplist.erase ( 0 ) ; / / return false , 0 is not in skiplist .
 skiplist.erase ( 1 ) ; / / return true .
 skiplist.search ( 1 ) ; / / return false , 1 has already been erased .
 Given an initial computer network connections . You can extract certain cables between two directly connected computers , and place them between any pair of disconnected computers to make them directly connected . Return the minimum number of times you need to do this in order to make all the computers connected . If it's not possible , return -1 .
 Given a string S , find the number of different non-empty palindromic subsequences in S , and return that number modulo 10 ^ 9 + 7 .
 There are n cities numbered from 1 to n . You are given an array edges of size n-1 , where edges [ i ] = [ u i , v i ] represents a bidirectional edge between cities u i and v i . There exists a unique path between each pair of cities . In other words , the cities form a tree .
 Your input will be several matchsticks the girl has , represented with their stick length . Your output will either be true or false , to represent whether you could make one square using all the matchsticks the little match girl has .
 The length sum of the given matchsticks is in the range of 0 to 10 ^ 9 .
 The length of the given matchstick array will not exceed 15 .
 getFront ( ) : Gets the front item from the Deque . If the deque is empty , return -1 .
 getRear ( ) : Gets the last item from Deque . If the deque is empty , return -1 .
 circularDeque.insertLast ( 1 ) ; / / return true
 circularDeque.insertLast ( 2 ) ; / / return true
 circularDeque.insertFront ( 3 ) ; / / return true
 circularDeque.insertFront ( 4 ) ; / / return false , the queue is full
 circularDeque.getRear ( ) ; / / return 2
 circularDeque.isFull ( ) ; / / return true
 circularDeque.deleteLast ( ) ; / / return true
 circularDeque.insertFront ( 4 ) ; / / return true
 circularDeque.getFront ( ) ; / / return 4
 Given the array nums , obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence .
 If there are multiple solutions , return the subsequence with minimum size and if there still exist multiple solutions , return the subsequence with the maximum total sum of all its elements . A subsequence of an array can be obtained by erasing some ( possibly zero ) elements from the array .
 Note that the solution with the given constraints is guaranteed to be unique . Also return the answer sorted in non-increasing order .
 You are given a string s and an array of strings words of the same length . Return all starting indices of substring ( s ) in s that is a concatenation of each word in words exactly once , in any order , and without any intervening characters .
 You can return the answer in any order .
 The output order does not matter , returning [ 9,0 ] is fine too .
 Given an input string s , reverse the order of the words .
 Given a binary tree , write a function to get the maximum width of the given tree . The maximum width of a tree is the maximum width among all levels .
 The given binary tree will have between 1 and 3000 nodes .
 Given n and k , return the k th permutation sequence .
 The order of output does not matter .
 You should return a NestedInteger object which contains a single integer 324 .
 Given row N and index K , return the K-th indexed symbol in row N . ( The values of K are 1-indexed . ) ( 1 indexed ) .
 With respect to a given puzzle string , a word is valid if both the following conditions are satisfied :
 Return an array answer , where answer [ i ] is the number of words in the given word list words that are valid with respect to the puzzle puzzles [ i ] .
 Players take turns placing characters into empty squares ( " " ) .
 Return the winner of the game if it exists ( A or B ) , in case the game ends in a draw return " Draw " , if there are still movements to play return " Pending " .
 Return the maximum score of any valid set of words formed by using the given letters ( words [ i ] can not be used two or more times ) .
 It is not necessary to use all characters in letters and each letter can only be used once . Score of letters' a' ,' b' ,' c' , ... ,' z' is given by score [ 0 ] , score [ 1 ] , ... , score [ 25 ] respectively .
 Given a sorted ( in ascending order ) integer array nums of n elements and a target value , write a function to search target in nums . If target exists , then return its index , otherwise return-1 .
 Explanation : 2 does not exist in nums so return -1
 Input : " Let's take LeetCode contest "
 Do not allocate extra space for another array , you must do this by modifying the input array in-place with O ( 1 ) extra memory .
 Note that the input array is passed in by reference , which means a modification to the input array will be known to the caller as well .
 Explanation : Your function should return length = 2 , with the first two elements of nums being 1 and 2 respectively . It doesn't matter what you leave beyond the returned length .
 Explanation : Your function should return length = 5 , with the first five elements of nums being modified to 0 , 1 , 2 , 3 , and 4 respectively . It doesn't matter what values are set beyond the returned length .
 In a given integer array nums , there is always exactly one largest element .
 If it is , return the index of the largest element , otherwise return -1 .
 6 is more than twice as big as x . The index of value 6 is 1 , so we return 1 .
 Explanation : 4 isn't at least as big as twice the value of 3 , so we return -1 .
 You are given an array of positive integers w where w [ i ] describes the weight of i th index ( 0-indexed ) .
 We need to call the function pickIndex ( ) which randomly returns an integer in the range [ 0 , w.length-1 ] . pickIndex ( ) should return the integer proportional to its weight in the w array . For example , for w = [ 1 , 3 ] , the probability of picking the index 0 is 1 / ( 1 + 3 ) = 0.25 ( i.e 25 % ) while the probability of picking the index 1 is 3 / ( 1 + 3 ) = 0.75 ( i.e 75 % ) .
 solution.pickIndex ( ) ; / / return 0 . Since there is only one single element on the array the only option is to return the first element .
 solution.pickIndex ( ) ; / / return 1 . It's returning the second element ( index = 1 ) that has probability of 3/4 .
 solution.pickIndex ( ) ; / / return 1
 solution.pickIndex ( ) ; / / return 1
 solution.pickIndex ( ) ; / / return 1
 solution.pickIndex ( ) ; / / return 0 . It's returning the first element ( index = 0 ) that has probability of 1/4 .
 Given a paragraph and a list of banned words , return the most frequent word that is not in the list of banned words . It is guaranteed there is at least one word that isn't banned , and that the answer is unique .
 Words in the list of banned words are given in lowercase , and free of punctuation . Words in the paragraph are not case sensitive . The answer is in lowercase .
 Alex and Lee take turns , with Alex starting first . Each turn , a player takes the entire pile of stones from either the beginning or the end of the row . This continues until there are no more piles left , at which point the person with the most stones wins .
 Assuming Alex and Lee play optimally , return True if and only if Alex wins the game .
 Alex starts first , and can only take the first 5 or the last 5 .
 This demonstrated that taking the first 5 was a winning move for Alex , so we return true .
 Given the root of a binary tree , then value v and depth d , you need to add a row of nodes with value v at the given depth d . The root node is at depth 1 .
 The adding rule is : given a positive integer depth d , for each NOT null tree nodes N in depth d-1 , create two tree nodes with value v as N's left subtree root and right subtree root . And N's original left subtree should be the left subtree of the new left subtree root , its original right subtree should be the right subtree of the new right subtree root . If depth d is 1 that means there is no depth d-1 at all , then create a tree node with value v as the new root of the whole original tree , and the original tree is the new root's left subtree .
 The given d is in range [ 1 , maximum depth of the given tree + 1 ] .
 The given binary tree has at least one tree node .
 Note that in some languages such as Java , there is no unsigned integer type . In this case , the input will be given as a signed integer type . It should not affect your implementation , as the integer's internal binary representation is the same , whether it is signed or unsigned .
 In Java , the compiler represents the signed integers using 2's complement notation . Therefore , in Example 3 above , the input represents the signed integer .-3 .
 Explanation : The input binary string 00000000000000000000000000001011 has a total of three' 1' bits .
 Explanation : The input binary string 00000000000000000000000010000000 has a total of one' 1' bit .
 Explanation : The input binary string 11111111111111111111111111111101 has a total of thirty one' 1' bits .
 The input must be a binary string of length 32
 The cost of painting a digit ( i +1 ) is given by cost [ i ] ( 0 indexed ) .
 Since the answer may be too large , return it as string .
 If there is no way to paint any integer given the condition , return " 0 " .
 When two ants moving in two different directions meet at some point , they change their directions and continue moving again . Assume changing directions doesn't take any additional time .
 Given an unsorted array of integers nums , return the length of the longest consecutive elements sequence .
 A zero-indexed array A consisting of N numbers is given . A subsequence slice of that array is any sequence of integers ( P 0 , P 1 , ... , P k ) such that 0 â‰¤ P 0 &lt; P 1 &lt; ... &lt; P k &lt; N.
 The function should return the number of arithmetic subsequence slices in the array A.
 The input contains N integers . Every integer is in the range of -2 31 and 2 31-1 and 0 â‰¤ N â‰¤ 1000 . The output is guaranteed to be less than 2 31-1 .
 Given an array of integers nums and an integer target , return indices of the two numbers such that they add up to target .
 You may assume that each input would have exactly one solution , and you may not use the same element twice .
 You can return the answer in any order .
 Output : Because nums [ 0 ] + nums [ 1 ] == 9 , we return [ 0 , 1 ] .
 You are given two non-empty linked lists representing two non-negative integers . The digits are stored in reverse order , and each of their nodes contains a single digit . Add the two numbers and return the sum as a linked list .
 For a given number N in base-10 , return the complement of it's binary representation as a base-10 integer .
 Given a binary tree , return the sum of values of nodes with even-valued grandparent . ( A grandparent of a node is the parent of its parent , if it exists . )
 If there are no nodes with an even-valued grandparent , return 0 .
 Given two strings S and T , return if they are equal when both are typed into empty text editors . # means a backspace character .
 After doing so , return the final string . If there is no way to do so , return the empty string .
 Return the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts . Since the answer can be a huge number , return this modulo 10 ^ 9 + 7 .
 Explanation : The figure above represents the given rectangular cake . Red lines are the horizontal and vertical cuts . After you cut the cake , the green piece of cake has the maximum area .
 Explanation : The figure above represents the given rectangular cake . Red lines are the horizontal and vertical cuts . After you cut the cake , the green and yellow pieces of cake have the maximum area .
 Given an array of integers A sorted in non-decreasing order , return an array of the squares of each number , also in sorted non-decreasing order .
 Given two lists , scores and ages , where each scores [ i ] and ages [ i ] represents the score and age of the i th player , respectively , return the highest overall score of all possible basketball teams .
 Return the number of possible playlists . As the answer can be very large , return it modulo 10 ^ 9 + 7 .
 In a 2D grid from ( 0 , 0 ) to ( N-1 , N-1 ) , every cell contains a 1 , except those cells in the given list mines which are 0 . What is the largest axis-aligned plus sign of 1 s contained in the grid ? Return the order of the plus sign . If there is none , return 0 .
 There is no plus sign , so return 0 .
 Level 1 of videos are all watched videos by your friends , level 2 of videos are all watched videos by the friends of your friends and so on . In general , the level k of videos are all watched videos by people with the shortest path exactly equal to k with you . Given your id and the level of videos , return the list of videos ordered by their frequencies ( increasing ) . For videos with the same frequency order them alphabetically from least to greatest .
 Given two arrays of integers nums1 and nums2 , return the number of triplets formed ( type 1 and type 2 ) under the following rules :
 Given a string s , return the longest palindromic substring in s .
 The length of given words won't exceed 500 .
 Characters in given words can only be lower-case letters .
 Given an N x N grid containing only values 0 and 1 , where 0 represents water and 1 represents land , find a water cell such that its distance to the nearest land cell is maximized and return the distance .
 If no land or water exists in the grid , return-1 .
 The given num does not contain any leading zero .
 Explanation : Remove the leading 1 and the number is 200 . Note that the output must not contain leading zeroes .
 The number of nodes in the given tree will be in the range [ 1 , 1000 ] .
 Given an array nums containing n distinct numbers in the range [ 0 , n ] , return the only number in the range that is missing from the array .
 You receive a valid board , made of only battleships or empty slots .
 This is an invalid board that you will not receive-as battleships will always have a cell separating between them .
 You may assume that the given expression is always valid .
 We are given a binary tree ( with root node root ) , a target node , and an integer value K .
 The given tree is non-empty .
 Given 2n balls of k distinct colors . You will be given an integer array balls of size k where balls [ i ] is the number of balls of color i .
 There are several stones arranged in a row , and each stone has an associated value which is an integer given in the array stoneValue .
 Return the maximum score that Alice can obtain .
 Given the array-form A of a non-negative integer X , return the array-form of the integer X+K .
 Given an integer n , return a string with n characters such that each character in such string occurs an odd number of times .
 The returned string must contain only lowercase English letters . If there are multiples valid strings , return any of them .
 Given two strings a and b , return the minimum number of times you should repeat string a so that string b is a substring of it . If it is impossible for b to be a substring of a after repeating it , return-1 .
 Explanation : We return 3 because by repeating a three times " ab cdabcdab cd " , b is a substring of it .
 Given an integer array , return the k-th smallest distance among all the pairs . The distance of a pair ( A , B ) is defined as the absolute difference between A and B .
 Now , we would like to implement the following query function : TopVotedCandidate.q ( int t ) will return the number of the person that was leading the election at time t .
 Return the k th bit in S n . It is guaranteed that k is valid for the given n .
 You are given an array customers of length n where customers [ i ] is the number of new customers arriving just before the i th rotation ( 0-indexed ) . This means you must rotate the wheel i times before the customers [ i ] customers arrive . You can not make customers wait if there is room in the gondola . Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again .
 Return the minimum number of rotations you need to perform to maximize your profit . If there is no scenario where the profit is positive , return-1 .
 The profit was never positive , so return -1 .
 The input string is " ( ( ) ( ) ) ( ( ) ) " , with primitive decomposition " ( ( ) ( ) ) " + " ( ( ) ) " .
 The input string is " ( ( ) ( ) ) ( ( ) ) ( ( ) ( ( ) ) ) " , with primitive decomposition " ( ( ) ( ) ) " + " ( ( ) ) " + " ( ( ) ( ( ) ) ) " .
 The input string is " ( ) ( ) " , with primitive decomposition " ( ) " + " ( ) " .
 The number of nodes in the given tree will be between 1 and 100 .
 You are given an integer array groupSizes , where groupSizes [ i ] is the size of the group that person i is in . For example , if groupSizes [ 1 ] = 3 , then person 1 must be in a group of size 3 .
 Each person should appear in exactly one group , and every person must be in a group . If there are multiple answers , return any of them . It is guaranteed that there will be at least one valid solution for the given input .
 Now given a string representing n , you should return the smallest good base of n in string format .
 You may return the answer in any order .
 We are given S , a length n string of characters from the set { 'D' ,' I' } . ( These letters stand for " decreasing " and " increasing " . )
 How many valid permutations are there ? Since the answer may be large , return your answer modulo 10 ^ 9 + 7 .
 The value in the given matrix is in the range of [ 0 , 255 ] .
 The length and width of the given matrix are in the range of [ 1 , 150 ] .
 Each employee has one direct manager given in the manager array where manager [ i ] is the direct manager of the i-th employee , manager [ headID ] = -1 . Also it's guaranteed that the subordination relationships have a tree structure .
 Given an array consisting of n integers , find the contiguous subarray of given length k that has the maximum average value . And you need to output the maximum average value .
 Elements of the given array will be in the range [-10,000 , 10,000 ] .
 The parts should be in order of occurrence in the input list , and parts occurring earlier should always have a size greater than or equal parts occurring later .
 The input and each element of the output are ListNodes , not arrays .
 For example , the input root has root.val = 1 , root.next.val = 2 , \ root.next.next.val = 3 , and root.next.next.next = null .
 The first element output [ 0 ] has output [ 0 ] . val = 1 , output [ 0 ] . next = null .
 The last element output [ 4 ] is null , but it's string representation as a ListNode is [ ] .
 The input has been split into consecutive parts with size difference at most 1 , and earlier parts are a larger size than the later parts .
 Each value of a node in the input will be an integer in the range [ 0 , 999 ] .
 Given the integer n representing the number of courses at some university labeled from 1 to n , and the array dependencies where dependencies [ i ] = [ x i , y i ] represents a prerequisite relationship , that is , the course x i must be taken before the course y i . Also , you are given the integer k .
 In one semester you can take at most k courses as long as you have taken all the prerequisites for the courses you are taking .
 Return the minimum number of semesters to take all courses . It is guaranteed that you can take all courses in some way .
 Explanation : The figure above represents the given graph . In this case we can take courses 2 and 3 in the first semester , then take course 1 in the second semester and finally take course 4 in the third semester .
 Explanation : The figure above represents the given graph . In this case one optimal way to take all courses is : take courses 2 and 3 in the first semester and take course 4 in the second semester , then take course 1 in the third semester and finally take course 5 in the fourth semester .
 The given graph is a directed acyclic graph .
 Now given a positive number N , how many numbers X from 1 to N are good ?
 You are given a list of strings logs where logs [ i ] is the operation performed by the user at the i th step .
 Return the shortest such subarray and output its length .
 Alice has a hand of cards , given as an array of integers .
 Given a 2D grid of 0 s and 1 s , return the number of elements in the largest square subgrid that has all 1 s on its border , or 0 if such a subgrid doesn't exist in the grid .
 Given a list of three points in the plane , return whether these points are a boomerang .
 Given a non-empty binary tree , return the average value of the nodes on each level in the form of an array .
 The average value of nodes on level 0 is 3 , on level 1 is 14.5 , and on level 2 is 11 . Hence return [ 3 , 14.5 , 11 ] .
 Given an array A of strings made only from lowercase letters , return a list of all characters that show up in all strings within the list ( including duplicates ) . For example , if a character occurs 3 times in all strings but not 4 times , you need to include that character three times in the final answer .
 You may return the answer in any order .
 You are given an undirected weighted graph of n nodes ( 0-indexed ) , represented by an edge list where edges [ i ] = [ a , b ] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb [ i ] .
 Given two nodes start and end , find the path with the maximum probability of success to go from start to end and return its success probability .
 If there is no path from start to end , return 0 . Your answer will be accepted if it differs from the correct answer by at most 1e-5 .
 Given a binary tree and a sum , find all root-to-leaf paths where each path's sum equals the given sum .
 Given two non-negative integers num1 and num2 represented as strings , return the product of num1 and num2 , also represented as a string .
 Find the maximum number of substrings that meet the above conditions . If there are multiple solutions with the same number of substrings , return the one with minimum total length . It can be shown that there exists a unique solution of minimum total length .
 Notice that you can return the substrings in any order .
 Implement the clumsy function as defined above : given an integer N , it returns the clumsy factorial of N .
 We are given two strings , A and B .
 Given an m x n matrix , return true if the matrix is Toeplitz . Otherwise , return false .
 We are given hours , a list of the number of hours worked per day for a given employee .
 We are given a linked list with head as the first node . Let's number the nodes in the list : node_1 , node_2 , node_3 , ... etc.
 The given list has length in the range [ 0 , 10000 ] .
 You are given the root of a binary search tree ( BST ) , where exactly two nodes of the tree were swapped by mistake . Recover the tree without changing its structure .
 Explanation :' e' must have been pressed twice , but it wasn't in the typed output .
 Explanation : Compressing s without deleting anything will give us " a3bc3d " of length 6 . Deleting any of the characters' a' or' c' would at most decrease the length of the compressed string to 5 , for instance delete 2' a' then we will have s = " abcccd " which compressed is abc3d . Therefore , the optimal way is to delete' b' and 'd' , then the compressed version of s will be " a3c3 " of length 4 .
 If there is no common prefix , return an empty string " " .
 Explanation : There is no common prefix among the input strings .
 Given an input string ( s ) and a pattern ( p ) , implement regular expression matching with support for' .' and' *' where :
 The matching should cover the entire input string ( not partial ) .
 With each iteration one element ( red ) is removed from the input data and inserted in-place into the sorted list
 Insertion sort iterates , consuming one input element each repetition , and growing a sorted output list .
 At each iteration , insertion sort removes one element from the input data , finds the location it belongs within the sorted list , and inserts it there .
 It repeats until no input elements remain .
 Given an array A of non-negative integers , return an array consisting of all the even elements of A , followed by all the odd elements of A .
 You may return any answer array that satisfies this condition .
 solution.shuffle ( ) ; / / Shuffle the array [ 1,2,3 ] and return its result . Any permutation of [ 1,2,3 ] must be equally likely to be returned . Example : return [ 3 , 1 , 2 ]
 solution.shuffle ( ) ; / / Returns the random shuffling of array [ 1,2,3 ] . Example : return [ 1 , 3 , 2 ]
 Given a binary search tree , return a balanced binary search tree with the same node values .
 If there is more than one answer , return any of them .
 Return any Fibonacci-like sequence split from S , or return [ ] if it can not be done .
 Explanation : The output [ 11 , 0 , 11 , 11 ] would also be accepted .
 Clarification : The input / output format is the same as how LeetCode serializes a binary tree . You do not necessarily need to follow this format , so please be creative and come up with different approaches yourself .
 On an infinite plane , a robot initially stands at ( 0 , 0 ) and faces north . The robot can receive one of three instructions :
 The robot performs the instructions given in order , and repeats them forever .
 Delete all insufficient nodes simultaneously , and return the root of the resulting binary tree .
 The given tree will have between 1 and 5000 nodes .
 You are given a list of strings of the same length words and a string target .
 Your task is to form target using the given words under the following rules :
 Return the number of ways to form target from words . Since the answer may be too large , return it modulo 10 9 + 7 .
 Two players play a turn based game on a binary tree . We are given the root of this binary tree , and the number of nodes n in the tree . n is odd , and each node has a distinct value from 1 to n .
 Then , the players take turns starting with the first player . In each turn , that player chooses a node of their color ( red if player 1 , blue if player 2 ) and colors an uncolored neighbor of the chosen node ( either the left child , right child , or parent of the chosen node . )
 You are the second player . If it is possible to choose such a y to ensure you win the game , return true . If it is not possible , return false .
 Given an array of integers with possible duplicates , randomly output the index of a given target number . You can assume that the given target number must exist in the array .
 / / pick ( 3 ) should return either index 2 , 3 , or 4 randomly . Each index should have equal probability of returning .
 / / pick ( 1 ) should return 0 . Since in the array only nums [ 0 ] is equal to 1 .
 productOfNumbers.getProduct ( 2 ) ; / / return 20 . The product of the last 2 numbers is 5 * 4 = 20
 productOfNumbers.getProduct ( 3 ) ; / / return 40 . The product of the last 3 numbers is 2 * 5 * 4 = 40
 productOfNumbers.getProduct ( 4 ) ; / / return 0 . The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0
 productOfNumbers.getProduct ( 2 ) ; / / return 32 . The product of the last 2 numbers is 4 * 8 = 32
 Given the root of a binary tree , return true if the binary tree is Even-Odd , otherwise return false .
 Since the answer may be too large , return it modulo 10 9 + 7 .
 Return the shortest distance between the given start and destination stops .
 You are given two groups of points where the first group has size 1 points , the second group has size 2 points , and size 1 &gt; = size 2 .
 The cost of the connection between any two points are given in an size 1 x size 2 matrix where cost [ i ] [ j ] is the cost of connecting point i of the first group and point j of the second group . The groups are connected if each point in both groups is connected to one or more points in the opposite group . In other words , each point in the first group must be connected to at least one point in the second group , and each point in the second group must be connected to at least one point in the first group .
 Given an array nums of positive integers . Your task is to select some subset of nums , multiply each element by an integer and add all these numbers . The array is said to be good if you can obtain a sum of 1 from the array by any possible subset and multiplicand .
 Return True if the array is good otherwise return False .
 Given an integer n , add a dot ( " . " ) as the thousands separator and return it in string format .
 Given two integer arrays arr1 and arr2 , return the minimum number of operations ( possibly zero ) needed to make arr1 strictly increasing .
 If there is no way to make arr1 strictly increasing , return-1 .
 The input array words contains at least one word .
 Every operation done is between two numbers . In particular , we can not use-as a unary operator . For example , with [ 1 , 1 , 1 , 1 ] as input , the expression-1-1-1-1 is not allowed .
 You can not concatenate numbers together . For example , if the input is [ 1 , 2 , 1 , 2 ] , we can not write this as 12 + 12 .
 Suppose you are given the following code :
 public void zero ( printNumber ) { ... } / / only output 0's
 public void even ( printNumber ) { ... } / / only output even numbers
 public void odd ( printNumber ) { ... } / / only output odd numbers
 Thread A will call zero ( ) which should only output 0's .
 Thread C will call odd ( ) which should only output odd numbers .
 Each of the threads is given a printNumber method to output an integer . Modify the given program to output the series 010203040506 ... where the length of the series must be 2 n .
 Explanation : There are three threads being fired asynchronously . One of them calls zero ( ) , the other calls even ( ) , and the last one calls odd ( ) . " 0102 " is the correct output .
 The graph is given as follows : edges [ k ] is a list of integer pairs ( i , j , n ) such that ( i , j ) is an edge of the original graph ,
 Return a list of the strongest k values in the array . return the answer in any arbitrary order .
 The given dates are guaranteed to be valid , so no error handling is necessary .
 What should we return when needle is an empty string ? This is a great question to ask during an interview .
 For the purpose of this problem , we will return 0 when needle is an empty string . This is consistent to C's strstr ( ) and Java's indexOf ( ) .
 Given an integer array , your task is to find all the different possible increasing subsequences of the given array , and the length of an increasing subsequence should be at least 2 .
 The length of the given array will not exceed 15 .
 The range of integer in the given array is [-100,100 ] .
 The given array may contain duplicates , and two equal integers should also be considered as a special case of increasing sequence .
 Given two binary trees original and cloned and given a reference to a node target in the original tree .
 Explanation : Using cuts order = [ 1 , 3 , 4 , 5 ] as in the input leads to the following scenario :
 Explanation : If you try the given cuts ordering the cost will be 25 .
 Given a column title as appear in an Excel sheet , return its corresponding column number .
 You are given n points in the plane that are all distinct , where points [ i ] = [ x i , y i ] . A boomerang is a tuple of points ( i , j , k ) such that the distance between i and j equals the distance between i and k ( the order of the tuple matters ) .
 The move sequence is represented by a string , and the character moves [ i ] represents its ith move . Valid moves are R ( right ) , L ( left ) , U ( up ) , and D ( down ) . If the robot returns to the origin after it finishes all of its moves , return true . Otherwise , return false .
 Explanation : The robot moves up once , and then down once . All moves have the same magnitude , so it ended up at the origin where it started . Therefore , we return true .
 Explanation : The robot moves left twice . It ends up two " moves " to the left of the origin . We return false because it is not at the origin at the end of its moves .
 Given an unsorted array of integers nums , return the length of the longest continuous increasing subsequence ( i.e. subarray ) . The subsequence must be strictly increasing .
 Return the root of the trimmed binary search tree . Note that the root may change depending on the given bounds .
 Given a binary search tree ( BST ) , find the lowest common ancestor ( LCA ) of two given nodes in the BST .
 Given the root of a Binary Search Tree and a target number k , return true if there exist two elements in the BST such that their sum is equal to the given target .
 On each move , you can either go left or right . During the n-th move ( starting from 1 ) , you take n steps .
 Given two strings s and t , return the minimum window in s which will contain all the characters in t . If there is no such window in s that covers all characters in t , return the empty string " " .
 We are given two sentences A and B . ( A sentence is a string of space separated words . Each word consists only of lowercase letters . )
 You may return the list in any order .
 Given two axis-aligned rectangles rec1 and rec2 , return true if they overlap , otherwise return false .
 Given a sorted array nums , remove the duplicates in-place such that duplicates appeared at most twice and return the new length .
 Do not allocate extra space for another array ; you must do this by modifying the input array in-place with O ( 1 ) extra memory .
 Note that the input array is passed in by reference , which means a modification to the input array will be known to the caller .
 Explanation : Your function should return length = 5 , with the first five elements of nums being 1 , 1 , 2 , 2 and 3 respectively . It doesn't matter what you leave beyond the returned length .
 Explanation : Your function should return length = 7 , with the first seven elements of nums being modified to 0 , 0 , 1 , 1 , 2 , 3 and 3 respectively . It doesn't matter what values are set beyond the returned length .
 Given a binary tree , imagine yourself standing on the right side of it , return the values of the nodes you can see ordered from top to bottom .
 The input array will only contain 0 and 1 .
 The length of input array is a positive integer and will not exceed 10,000
 How many schemes can be chosen ? Since the answer may be very large , return it modulo 10 ^ 9 + 7 .
 SnapshotArray ( int length ) initializes an array-like data structure with the given length . Initially , each element equals 0 .
 void set ( index , val ) sets the element at the given index to be equal to val .
 int get ( index , snap_id ) returns the value at the given index , at the time we took the snapshot with the given snap_id
 snapshotArr.snap ( ) ; / / Take a snapshot , return snap_id = 0
 snapshotArr.get ( 0,0 ) ; / / Get the value of array [ 0 ] with snap_id = 0 , return 5
 Given an integer n , return how many distinct phone numbers of length n we can dial .
 As the answer may be very large , return the answer modulo 10 9 + 7 .
 Explanation : Please take care of the mod .
 Alice and Bob take turns playing a game , with Alice starting first .
 We will remove one node from the initial list . Return the node that if removed , would minimize M ( initial ) . If multiple nodes could be removed to minimize M ( initial ) , return such a node with the smallest index .
 We are given a list cpdomains of count-paired domains . We would like a list of count-paired domains , ( in the same format as the input , and in any order ) , that explicitly counts the number of visits to each subdomain .
 The input count in any count-paired domain will not exceed 10000 .
 The answer output can be returned in any order .
 The given number is guaranteed to fit within the range of a 32-bit signed integer .
 Step 1 ) 13 is odd , add 1 and obtain 14 .
 Step 2 ) 14 is even , divide by 2 and obtain 7 .
 Step 3 ) 7 is odd , add 1 and obtain 8 .
 Step 4 ) 8 is even , divide by 2 and obtain 4 .
 Step 5 ) 4 is even , divide by 2 and obtain 2 .
 Step 6 ) 2 is even , divide by 2 and obtain 1 .
 Step 1 ) 2 is even , divide by 2 and obtain 1 .
 Given n , the number of stones in the heap , return true if you can win the game assuming both you and your friend play optimally , otherwise return false .
 Using the above tables as example , return the following :
 Given a binary search tree ( BST ) with duplicates , find all the mode ( s ) ( the most frequently occurred element ) in the given BST .
 return [ 2 ] .
 Note : If a tree has more than one mode , you can return them in any order .
 Return the starting gas station's index if you can travel around the circuit once in the clockwise direction , otherwise return -1 .
 Both input arrays are non-empty and have the same length .
 Each element in the input arrays is a non-negative integer .
 Therefore , return 3 as the starting index .
 We are given the root node of a maximum tree : a tree where every node has a value greater than any other value in its subtree .
 Just as in the previous problem , the given tree was constructed from an list A ( root = Construct ( A ) ) recursively with the following Construct ( A ) routine :
 If A is empty , return null .
 Note that we were not given A directly , only a root node root = Construct ( A ) .
 After doing so , return the number of remaining intervals .
 The sum of elements of the 0-th ( upper ) row is given as upper .
 The sum of elements of the 1-st ( lower ) row is given as lower .
 The sum of elements in the i-th column ( 0-indexed ) is colsum [ i ] , where colsum is given as an integer array with length n .
 If no valid solution exists , return an empty 2-D array .
 You are given a series of video clips from a sporting event that lasted T seconds . These video clips can be overlapping with each other and have varied lengths .
 Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event ( [ 0 , T ] ) . If the task is impossible , return-1 .
 We take the clips [ 0,2 ] , [ 8,10 ] , [ 1,9 ] ; a total of 3 clips .
 We can take clips [ 0,4 ] , [ 4,7 ] , and [ 6,9 ] .
 The input tree is guaranteed to be a binary search tree .
 You are given a 2D char matrix representing the game board .' M' represents an unrevealed mine ,' E' represents an unrevealed empty square ,' B' represents a revealed blank square that has no adjacent ( above , below , left , right , and all 4 diagonals ) mines , digit (' 1' to' 8' ) represents how many mines are adjacent to this revealed square , and finally' X' represents a revealed mine .
 Now given the next click position ( row and column indices ) among all the unrevealed squares (' M' or' E' ) , return the board after revealing this position according to the following rules :
 The range of the input matrix's height and width is [ 1,50 ] .
 The click position will only be an unrevealed square (' M' or' E' ) , which also means the input board contains at least one clickable square .
 The input board won't be a stage when game is over ( some mines have been revealed ) .
 Given the root of a binary tree , return all duplicate subtrees .
 For each kind of duplicate subtrees , you only need to return the root node of any one of them .
 Given two integer arrays A and B , return the maximum length of an subarray that appears in both arrays .
 Given the root node of a binary search tree , return the sum of values of all nodes with a value in the range [ low , high ] .
 There is only one duplicate number in nums , return this duplicate number .
 Given an integer n , return the number of strings of length n that consist only of vowels ( a , e , i , o , u ) and are lexicographically sorted .
 Given a string s , you can convert it to a palindrome by adding characters in front of it . Find and return the shortest palindrome you can find by performing this transformation .
 Can you save the day ? If so , what is the number of walls required ? If not , and the world becomes fully infected , return the number of walls used .
 Our goal is to flip the least number of nodes in the tree so that the voyage of the tree matches the voyage we are given .
 If we can do so , then return a list of the values of all nodes flipped . You may return the answer in any order .
 If we can not do so , then return the list [-1 ] .
 For each call to the method MyCalendar.book , return true if the event can be added to the calendar successfully without causing a double booking . Otherwise , return false and do not add the event to the calendar .
 NOTE : input types have been changed on April 15 , 2019 . Please reset to default code definition to get new method signature .
 Note : The input will be a non-empty word consisting of uppercase and lowercase latin letters .
 You are given an array of k linked-lists lists , each linked-list is sorted in ascending order .
 Merge all the linked-lists into one sorted linked-list and return it .
 Say you have an array prices for which the i th element is the price of a given stock on day i .
 Under a grammar given below , strings can represent a set of lowercase words . Let's use R ( expr ) to denote the set of words the expression represents .
 When we take a comma delimited list of 2 or more expressions , we take the union of possibilities .
 When we concatenate two expressions , we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression .
 Given an expression representing a set of words under the given grammar , return the sorted list of words that the expression represents .
 The given expression represents a set of words based on the grammar given in the description .
 The given input is a graph that started as a tree with N nodes ( with distinct values 1 , 2 , ... , N ) , with one additional edge added . The added edge has two different vertices chosen from 1 to N , and was not an edge that already existed .
 The resulting graph is given as a 2D-array of edges . Each element of edges is a pair [ u , v ] with u &lt; v , that represents an undirected edge connecting nodes u and v .
 Return an edge that can be removed so that the resulting graph is a tree of N nodes . If there are multiple answers , return the answer that occurs last in the given 2D-array . The answer edge [ u , v ] should be in the same format , with u &lt; v .
 Explanation : The given undirected graph will be like this :
 Explanation : The given undirected graph will be like this :
 The size of the input 2D-array will be between 3 and 1000 .
 Every integer represented in the 2D-array will be between 1 and N , where N is the size of the input array .
 Alice and Bob continue their games with piles of stones . There are several stones arranged in a row , and each stone has an associated value which is an integer given in the array stoneValue .
 Alice and Bob take turns , with Alice starting first . On each player's turn , that player can take 1 , 2 or 3 stones from the first remaining stones in the row .
 Explanation : Alice will always lose . Her best move will be to take three piles and the score become 6 . Now the score of Bob is 7 and Bob wins .
 If Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5 . The next move Alice will take the pile with value = -9 and lose .
 If Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3 . The next move Alice will take the pile with value = -9 and also lose .
 Given a m * n matrix mat of integers , sort it diagonally in ascending order from the top-left to the bottom-right then return the sorted array .
 Given a rows x cols binary matrix filled with 0's and 1's , find the largest rectangle containing only 1's and return its area .
 Write a function strongPasswordChecker ( s ) , that takes a string s as input , and return the MINIMUM change required to make s a strong password . If s is already strong , return 0 .
 Given an integer array nums , find the contiguous subarray ( containing at least one number ) which has the largest sum and return its sum .
 Nary-Tree input serialization is represented in their level order traversal , each group of children is separated by the null value ( See examples ) .
 Given a N * N matrix M representing the friend relationship between students in the class . If M [ i ] [ j ] = 1 , then the i th and j th students are direct friends with each other , otherwise not . And you have to output the total number of friend circles among all the students .
 The 2 nd student himself is in a friend circle . So return 2 .
 so the 0 th and 2 nd students are indirect friends . All of them are in the same friend circle , so return 1 .
 An encoded string S is given . To find and write the decoded string to a tape , the encoded string is read one character at a time and the following steps are taken :
 Now for some encoded string S , and an index K , find and return the K-th letter ( 1 indexed ) in the decoded string .
